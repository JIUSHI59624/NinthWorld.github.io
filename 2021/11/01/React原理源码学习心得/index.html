

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="笔者于今年开始接触并接手React项目的研发，为了进一步学习React并了解其原理源码，笔者开始学习React的原理以及源码，主要的学习途径为一些网站(主要是卡颂大佬的React技术揭秘)，书籍，以及自己看源码等等，本文是笔者在学习React过程的笔记，以及本者本人对于React的一些理解。阅读本文前请确保你已经非常熟悉React，并且有一定的开发踩坑经验。">
  <meta name="author" content="NinthWorld">
  <meta name="keywords" content="前端,JavaScript,编程,React,算法,Vue,框架,学习,生活,随笔">
  <meta name="description" content="笔者于今年开始接触并接手React项目的研发，为了进一步学习React并了解其原理源码，笔者开始学习React的原理以及源码，主要的学习途径为一些网站(主要是卡颂大佬的React技术揭秘)，书籍，以及自己看源码等等，本文是笔者在学习React过程的笔记，以及本者本人对于React的一些理解。阅读本文前请确保你已经非常熟悉React，并且有一定的开发踩坑经验。">
<meta property="og:type" content="article">
<meta property="og:title" content="React原理源码系统性学习心得--React原理系列">
<meta property="og:url" content="git://ninthworld94.github.io/2021/11/01/React原理源码学习心得/index.html">
<meta property="og:site_name" content="NinthWorld的博客">
<meta property="og:description" content="笔者于今年开始接触并接手React项目的研发，为了进一步学习React并了解其原理源码，笔者开始学习React的原理以及源码，主要的学习途径为一些网站(主要是卡颂大佬的React技术揭秘)，书籍，以及自己看源码等等，本文是笔者在学习React过程的笔记，以及本者本人对于React的一些理解。阅读本文前请确保你已经非常熟悉React，并且有一定的开发踩坑经验。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="git:///2021/11/01/React原理源码学习心得/beginWork.png">
<meta property="og:image" content="git:///2021/11/01/React原理源码学习心得/completeWork.png">
<meta property="article:published_time" content="2021-11-01T13:35:34.000Z">
<meta property="article:modified_time" content="2021-11-01T13:35:34.000Z">
<meta property="article:author" content="NinthWorld">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="React">
<meta property="article:tag" content="React源码">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="git:///2021/11/01/React原理源码学习心得/beginWork.png">
  
  <title>React原理源码系统性学习心得--React原理系列 - NinthWorld的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"ninthworld94.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>天道酬勤</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://rmt.dogedoge.com/fetch/fluid/storage/bg/73twhs.png?w=1920&fmt=webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="React原理源码系统性学习心得--React原理系列">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-01 21:35" pubdate>
        2021年11月1日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      23k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      72 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">React原理源码系统性学习心得--React原理系列</h1>
            
            <div class="markdown-body">
              <p>笔者于今年开始接触并接手React项目的研发，为了进一步学习React并了解其原理源码，笔者开始学习React的原理以及源码，主要的学习途径为一些网站(主要是卡颂大佬的<a target="_blank" rel="noopener" href="https://react.iamkasong.com/">React技术揭秘</a>)，书籍，以及自己看源码等等，本文是笔者在学习React过程的笔记，以及本者本人对于React的一些理解。阅读本文前请确保你已经非常熟悉React，并且有一定的开发踩坑经验。</p>
<span id="more"></span>
<h1 id="React核心原理以及部分源码"><a href="#React核心原理以及部分源码" class="headerlink" title="React核心原理以及部分源码"></a>React核心原理以及部分源码</h1><h2 id="React哲学"><a href="#React哲学" class="headerlink" title="React哲学"></a>React哲学</h2><p>官网上对于React哲学的简介是:  </p>
<blockquote>
<p>“我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。”<br>因此对于React来说，如何构建快速响应的大型Web应用程序是核心。</p>
</blockquote>
<h3 id="React核心架构"><a href="#React核心架构" class="headerlink" title="React核心架构"></a>React核心架构</h3><p><strong>React15架构</strong>：</p>
<ul>
<li>Reconciler(协调器)<ul>
<li>找出变化的组件</li>
</ul>
</li>
<li>Renderer<ul>
<li>负责把变化的组件渲染到页面上  </li>
</ul>
</li>
</ul>
<p><strong>Reconciler(协调器)</strong>  </p>
<p>先说说React渲染原理：<br>在React中触发组件更新的操作有（不包括React Hook）：<br><code>this.setState</code>,<code>this.forceUpdate</code>,<code>ReactDOM.render</code>。<br>当有更新要发生时，Reconciler将开始工作，进行以下操作：  </p>
<ul>
<li>1.执行函数组件或执行Class Components的render方法，将返回的JSX通过React.createElement转换成虚拟DOM。</li>
<li>2.通过Diff算法将新旧虚拟DOM进行对比</li>
<li>3.通过对比得到最小更新范围</li>
<li>4.通知Renderer将本次的变更更新到真是DOM即页面上</li>
</ul>
<p><strong>Renderer(渲染器)</strong>  </p>
<p>React官方文档对于渲染器的解释是:</p>
<blockquote>
<p>渲染器用于管理一棵 React 树，使其根据底层平台进行不同的调用。  </p>
</blockquote>
<p>Renderer做的事情非常简单，就是：在每次更新发生时，Renderer接到Reconciler通知，将变化的组件渲染在当前宿主环境。<br>PS:不同平台有不同的Renderer，浏览器平台是React.DOM,RN上是ReactNative,还有ReactArt用于渲染到Canvas，SVG等</p>
<p><strong>缺点</strong></p>
<p>对于Reconciler,mount的组件会调用mountComponent，update的组件会调用updateComponent。这两个方法都会递归更新子组件。可参考源码：<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498">mountComponent</a>  <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877">updateComponent</a><br>总所周知，递归无法被中断，所以当子组件很多，递归层级很深时，会耗时非常长，而对于用户来讲，每一帧的刷新时间差不多是1６.６ms(1s/60FPS)，所以当递归更新的时间超过这个时间时，视觉上就会卡顿。<br>其实要解决这个问题就需要异步更新，但是React15当时并不支持异步更新，因此React16更新了架构。  </p>
<p><strong>React16架构</strong>  </p>
<p>React16架构中新增了Scheduler（调度器），所以新的架构分为：</p>
<ul>
<li>Scheduler（调度器）<ul>
<li>调度任务的优先级，高优任务优先进入Reconciler</li>
</ul>
</li>
<li>Reconciler（协调器）<ul>
<li>找出变化的组件</li>
</ul>
</li>
<li>Renderer（渲染器）<ul>
<li>负责将变化的组件渲染到页面上</li>
</ul>
</li>
</ul>
<p><strong>Scheduler（调度器）</strong>  </p>
<p>调度器的作用就是当浏览器有剩余时间时通知我们，因此作为任务中断的标准，除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。<br>ps: <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md">Scheduler</a>是独立于React的库  </p>
<p><strong>Reconciler（协调器）</strong>  </p>
<p>在React16中不在是用递归去更新，而是通过可中断的循环过程，每次循环都会调用shouldYield判断当前是否有剩余时间。部分源码如下:</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/** @noinline */</span><br><span class="hljs-keyword">function</span> workLoopConcurrent() &#123;<br>  // <span class="hljs-keyword">Perform</span> <span class="hljs-keyword">work</span> <span class="hljs-keyword">until</span> Scheduler asks us <span class="hljs-keyword">to</span> yield<br>  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-keyword">null</span> &amp;&amp; !shouldYield()) &#123;<br>    workInProgress = performUnitOfWork(workInProgress);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是仅此不作处理会导致，DOM渲染不完全。因此在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs maxima">export type SideEffectTag = number;<br><br>// Don&#x27;t change these two <span class="hljs-built_in">values</span>. They&#x27;re used by React Dev Tools.<br>export const NoEffect = <span class="hljs-comment">/*                     */</span> <span class="hljs-number">0b000000000000000</span>;<br>export const PerformedWork = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b000000000000001</span>;<br><br>// You can change the <span class="hljs-built_in">rest</span> (<span class="hljs-keyword">and</span> add more).<br>export const Placement = <span class="hljs-comment">/*                    */</span> <span class="hljs-number">0b000000000000010</span>;<br>export const Update = <span class="hljs-comment">/*                       */</span> <span class="hljs-number">0b000000000000100</span>;<br>export const PlacementAndUpdate = <span class="hljs-comment">/*           */</span> <span class="hljs-number">0b000000000000110</span>;<br>export const Deletion = <span class="hljs-comment">/*                     */</span> <span class="hljs-number">0b000000000001000</span>;<br>export const ContentReset = <span class="hljs-comment">/*                 */</span> <span class="hljs-number">0b000000000010000</span>;<br>export const Callback = <span class="hljs-comment">/*                     */</span> <span class="hljs-number">0b000000000100000</span>;<br>export const DidCapture = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b000000001000000</span>;<br>export const Ref = <span class="hljs-comment">/*                          */</span> <span class="hljs-number">0b000000010000000</span>;<br>export const Snapshot = <span class="hljs-comment">/*                     */</span> <span class="hljs-number">0b000000100000000</span>;<br>export const Passive = <span class="hljs-comment">/*                      */</span> <span class="hljs-number">0b000001000000000</span>;<br>export const PassiveUnmountPendingDev = <span class="hljs-comment">/*     */</span> <span class="hljs-number">0b010000000000000</span>;<br>export const Hydrating = <span class="hljs-comment">/*                    */</span> <span class="hljs-number">0b000010000000000</span>;<br>export const HydratingAndUpdate = <span class="hljs-comment">/*           */</span> <span class="hljs-number">0b000010000000100</span>;<br><br>// Passive &amp; Update &amp; Callback &amp; Ref &amp; Snapshot<br>export const LifecycleEffectMask = <span class="hljs-comment">/*          */</span> <span class="hljs-number">0b000001110100100</span>;<br><br>// Union of all host effects<br>export const HostEffectMask = <span class="hljs-comment">/*               */</span> <span class="hljs-number">0b000011111111111</span>;<br><br>// These are <span class="hljs-keyword">not</span> really side effects, but we still reuse this field.<br>export const Incomplete = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b000100000000000</span>;<br>export const ShouldCapture = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b001000000000000</span>;<br>export const ForceUpdateForLegacySuspense = <span class="hljs-comment">/* */</span> <span class="hljs-number">0b100000000000000</span>;<br><br>// Union of side effect groupings as pertains to subtreeTag<br>export const BeforeMutationMask = <span class="hljs-comment">/*           */</span> <span class="hljs-number">0b000001100001010</span>;<br>export const MutationMask = <span class="hljs-comment">/*                 */</span> <span class="hljs-number">0b000010010011110</span>;<br>export const LayoutMask = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b000000010100100</span>;<br></code></pre></td></tr></table></figure>
<p>只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。  </p>
<p><strong>Renderer（渲染器）</strong>  </p>
<p>Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。<br>因此，并中断的只有Scheduler通知Reconciler以及Reconciler产生虚拟DOM以及打标记的过程，并不会中断Renderer的渲染，因此不会造成不完全的DOM。  </p>
<h3 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h3><p>从React16开始采用了新的Reconciler，新的Reconciler采用了Fiber架构。  </p>
<p>如何理解Fiber？先简单做一个定义：  </p>
<blockquote>
<p>React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。  </p>
</blockquote>
<p>其中每个任务更新单元为React Element对应的Fiber节点。</p>
<p><strong>Fiber含义：</strong></p>
<ul>
<li>1.作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。</li>
<li>2.作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的DOM节点等信息。</li>
<li>3.作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。</li>
</ul>
<p><strong>Fiber结构：</strong><br>先来看看<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiber.new.js#L117">Fiber</a>的源码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function FiberNode(<br>  tag: WorkTag,<br>  pendingProps: mixed,<br>  key: <span class="hljs-literal">null</span> | string,<br>  mode: TypeOfMode,<br>) &#123;<br>  <span class="hljs-comment">// Instance 当前节点的一些静态属性</span><br><br>  <span class="hljs-comment">// Fiber对应组件的类型 Function/Class/Host...</span><br>  <span class="hljs-keyword">this</span>.tag = tag;<br><br>  <span class="hljs-keyword">this</span>.key = key;<br>  <span class="hljs-keyword">this</span>.elementType = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName</span><br>  <span class="hljs-keyword">this</span>.type = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// Fiber对应的真实DOM节点</span><br>  <span class="hljs-keyword">this</span>.stateNode = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// Fiber  连接其他节点，形成Fiber树</span><br><br>  <span class="hljs-comment">// 指向父级Fiber节点</span><br>  <span class="hljs-keyword">this</span>.<span class="hljs-keyword">return</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 指向子Fiber节点</span><br>  <span class="hljs-keyword">this</span>.child = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 指向右边第一个兄弟Fiber节点</span><br>  <span class="hljs-keyword">this</span>.sibling = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">this</span>.index = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">this</span>.ref = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 作为调度任务的信息属性</span><br><br>  <span class="hljs-comment">// 保存本次更新造成的状态改变相关信息</span><br>  <span class="hljs-keyword">this</span>.pendingProps = pendingProps;<br>  <span class="hljs-keyword">this</span>.memoizedProps = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.updateQueue = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.memoizedState = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.dependencies = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">this</span>.mode = mode;<br><br>  <span class="hljs-comment">// Effects</span><br><br>  <span class="hljs-comment">// 保存本次更新会造成的DOM操作</span><br>  <span class="hljs-keyword">this</span>.effectTag = NoEffect;<br>  <span class="hljs-keyword">this</span>.subtreeTag = NoSubtreeEffect;<br>  <span class="hljs-keyword">this</span>.deletions = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.nextEffect = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">this</span>.firstEffect = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.lastEffect = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 调度优先级相关</span><br>  <span class="hljs-keyword">this</span>.lanes = NoLanes;<br>  <span class="hljs-keyword">this</span>.childLanes = NoLanes;<br><br>  <span class="hljs-comment">// 指向该fiber在另一次更新时对应的fiber</span><br>  <span class="hljs-keyword">this</span>.alternate = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Fiber执行机制</strong></p>
<p>双缓存Fiber树：  </p>
<p>在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。  </p>
<p>并且二者通过一下方式链接：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">currentFiber.alternate</span> === workInProgressFiber<span class="hljs-comment">;</span><br><span class="hljs-attr">workInProgressFiber.alternate</span> === currentFiber<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>Fiber在渲染更新中的切换机制是：</p>
<blockquote>
<p>React应用的根节点通过使current指针在不同Fiber树的rootFiber间切换来完成current Fiber树指向的切换。<br>即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。<br>每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。  </p>
</blockquote>
<p>这部细节可以看卡颂大佬的文章。</p>
<h2 id="JSX本质"><a href="#JSX本质" class="headerlink" title="JSX本质"></a>JSX本质</h2><p>在React中，JSX在编译时会被Babel编译为React.createElement。当然也可以指定编译为其他函数，因此并不是只有React才能使用JSX，可以通过@babel/plugin-transform-react-jsx (opens new window)插件显式告诉Babel编译时需要将JSX编译为什么函数的调用。</p>
<h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h3><p>先来看看代码：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> createElement(<span class="hljs-keyword">type</span>, <span class="hljs-keyword">config</span>, children) &#123;<br>  <span class="hljs-keyword">let</span> propName;<br><br>  <span class="hljs-keyword">const</span> props = &#123;&#125;;<br><br>  <span class="hljs-keyword">let</span> key = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">ref</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> self = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> source = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">config</span> != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 将 config 处理后赋值给 props</span><br>    <span class="hljs-comment">// ...省略</span><br>  &#125;<br><br>  <span class="hljs-keyword">const</span> childrenLength = arguments<span class="hljs-variable">.length</span> - <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// 处理 children，会被赋值给props.children</span><br>  <span class="hljs-comment">// ...省略</span><br><br>  <span class="hljs-comment">// 处理 defaultProps</span><br>  <span class="hljs-comment">// ...省略</span><br><br>  <span class="hljs-keyword">return</span> ReactElement(<br>    <span class="hljs-keyword">type</span>,<br>    key,<br>    <span class="hljs-keyword">ref</span>,<br>    self,<br>    source,<br>    ReactCurrentOwner<span class="hljs-variable">.current</span>,<br>    props,<br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> ReactElement = <span class="hljs-keyword">function</span>(<span class="hljs-keyword">type</span>, key, <span class="hljs-keyword">ref</span>, self, source, owner, props) &#123;<br>  <span class="hljs-keyword">const</span> element = &#123;<br>    <span class="hljs-comment">// 标记这是个 React Element</span><br>    $$typeof: REACT_ELEMENT_TYPE,<br><br>    <span class="hljs-keyword">type</span>: <span class="hljs-keyword">type</span>,<br>    key: key,<br>    <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">ref</span>,<br>    props: props,<br>    <span class="hljs-number">_</span>owner: owner,<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> element;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>可以看到React.createElement接受三个参数，第一个是type,一般指标签的类型，自定义组件等等，第二个是config指标签和组件上的props属性，第三个是children代表子节点，子组件。最终React.createElement返回的也就是ReactElement。  </p>
<p>可以看到ReactElement上是没有之前提到的Fiber的一些信息：</p>
<blockquote>
<ul>
<li>组件在更新中的优先级  </li>
<li>组件的state  </li>
<li>组件被打上的用于Renderer的标记  </li>
</ul>
</blockquote>
<p>因此，在组件mount时，Reconciler根据JSX描述的组件内容生成组件对应的Fiber节点。</p>
<p>在update时，Reconciler将JSX与Fiber节点保存的数据对比，生成组件对应的Fiber节点，并根据对比结果为Fiber节点打上标记。</p>
<h2 id="Render阶段"><a href="#Render阶段" class="headerlink" title="Render阶段"></a>Render阶段</h2><p>在render阶，如果是同步更新会调用<code>performSyncWorkOnRoot</code>,如果是异步更新则会调用<code>performConcurrentWorkOnRoot</code>。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// performSyncWorkOnRoot会调用该方法</span><br><span class="hljs-keyword">function</span> work<span class="hljs-constructor">LoopSync()</span> &#123;<br>  <span class="hljs-keyword">while</span> (workInProgress !== null) &#123;<br>    perform<span class="hljs-constructor">UnitOfWork(<span class="hljs-params">workInProgress</span>)</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// performConcurrentWorkOnRoot会调用该方法</span><br><span class="hljs-keyword">function</span> work<span class="hljs-constructor">LoopConcurrent()</span> &#123;<br>  <span class="hljs-keyword">while</span> (workInProgress !== null<span class="hljs-operator"> &amp;&amp; </span>!should<span class="hljs-constructor">Yield()</span>) &#123;<br>    perform<span class="hljs-constructor">UnitOfWork(<span class="hljs-params">workInProgress</span>)</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>二者的区别只有如果是异步更新，会在其中加中断条件<code>shouldYield</code>,如果当前浏览器帧没有剩余时间，会终止循环，等到浏览器空闲时继续遍历。</p>
<p>workInProgress代表当前已创建的workInProgress fiber。</p>
<p>performUnitOfWork方法会创建下一个Fiber节点并赋值给workInProgress，并将workInProgress与已创建的Fiber节点连接起来构成Fiber树。</p>
<h3 id="Render流程"><a href="#Render流程" class="headerlink" title="Render流程"></a>Render流程</h3><ul>
<li>1.首先会从<code>rootFiber</code>开始进行深度优先遍历，对于每一个遍历的<code>Fiber</code>节点，都会调用<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058">beginWork</a>方法。  </li>
<li>2.<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058">beginWork</a>方法根据传入的<code>Fiber</code>节点，创建子<code>Fiber</code>节点，并且将两个节点连接起来。</li>
<li>3.当遍历到叶子节点，会开始执行<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652">completeWork</a>处理节点。  <ul>
<li>当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），则对其兄弟节点进行<code>beginWork</code>。</li>
<li>如果不存在兄弟Fiber，对父节点调用<code>completeWork</code>。</li>
<li>最终会回到<code>rootFiber</code>节点，至此整个<code>render</code>阶段就结束了  </li>
</ul>
</li>
</ul>
<h4 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h4><p>根据 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058">beginWork</a> 源码。<br>首先，<code>beginWork</code> 接三个参数:</p>
<ul>
<li>current：当前组件对应的Fiber节点在上一次更新时的Fiber节点，即workInProgress.alternate</li>
<li>workInProgress：当前组件对应的Fiber节点</li>
<li>renderLanes：和渲染优先级相关<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts">function beginWork(<br><span class="hljs-symbol">  current:</span> Fiber | null,<br><span class="hljs-symbol">  workInProgress:</span> Fiber,<br><span class="hljs-symbol">  renderLanes:</span> Lanes,<br>): Fiber | <span class="hljs-class">null </span>&#123;<br>  <span class="hljs-comment">// ...省略函数体</span><br>&#125;<br></code></pre></td></tr></table></figure>
根据之前讲得双缓存Fiber树，假如组件是第一次<code>mount</code>那么<code>beginWork</code>的<code>current</code>参数就是<code>null</code>，因此beginWork通过判断<code>current===null</code>来区组件是<code>mount</code>还是<code>update</code>。  </li>
</ul>
<p>代码逻辑如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">function <span class="hljs-title">beginWork</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  current: Fiber | <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  workInProgress: Fiber,</span></span><br><span class="hljs-params"><span class="hljs-function">  renderLanes: Lanes</span></span><br><span class="hljs-params"><span class="hljs-function"></span>): Fiber | <span class="hljs-literal">null</span></span> &#123;<br><br>  <span class="hljs-comment">// update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）</span><br>  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// ...省略</span><br><br>    <span class="hljs-comment">// 复用current</span><br>    <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(<br>      current,<br>      workInProgress,<br>      renderLanes,<br>    );<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    didReceiveUpdate = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// mount时：根据tag不同，创建不同的子Fiber节点</span><br>  <span class="hljs-keyword">switch</span> (workInProgress.tag) &#123;<br>    <span class="hljs-keyword">case</span> IndeterminateComponent: <br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-keyword">case</span> LazyComponent: <br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-keyword">case</span> FunctionComponent: <br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-keyword">case</span> ClassComponent: <br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-keyword">case</span> HostRoot:<br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-keyword">case</span> HostComponent:<br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-keyword">case</span> HostText:<br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-comment">// ...省略其他类型</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以可以把beginWork的工作分为两个部分：</p>
<p>update时：如果current存在，且满足一定条件时，复用current节点，克隆current.child作为workInProgress.child。</p>
<p>mount时：除fiberRootNode以外，根据fiber.tag不同，创建不同类型的子Fiber节点。</p>
<p><strong>update</strong>  </p>
<p>update部分代码逻辑如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">current</span> !== <span class="hljs-keyword">null</span>) &#123;<br>    const oldProps = <span class="hljs-keyword">current</span>.memoizedProps;<br>    const newProps = workInProgress.pendingProps;<br><br>    <span class="hljs-keyword">if</span> (<br>      oldProps !== newProps ||<br>      hasLegacyContextChanged() ||<br>      (__DEV__ ? workInProgress.<span class="hljs-keyword">type</span> !== <span class="hljs-keyword">current</span>.<span class="hljs-keyword">type</span> : <span class="hljs-keyword">false</span>)<br>    ) &#123;<br>      didReceiveUpdate = <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!includesSomeLane(renderLanes, updateLanes)) &#123;<br>      didReceiveUpdate = <span class="hljs-keyword">false</span>;<br>      switch (workInProgress.tag) &#123;<br>        // 省略处理<br>      &#125;<br>      <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(<br>        <span class="hljs-keyword">current</span>,<br>        workInProgress,<br>        renderLanes,<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      didReceiveUpdate = <span class="hljs-keyword">false</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    didReceiveUpdate = <span class="hljs-keyword">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，当满足:</p>
<ul>
<li>1.<code>oldProps === newProps &amp;&amp; workInProgress.type === current.type</code> 即props与fiber.type都不变</li>
<li>2.<code>!includesSomeLane(renderLanes, updateLanes)</code>，即当前Fiber节点优先级不够。 </li>
</ul>
<p>如果满足上述条件，<code>didReceiveUpdate === false</code>（即可以直接复用前一次更新的子Fiber，不需要新建子Fiber）。  </p>
<p><strong>mount</strong>  </p>
<p>当不满足<code>update</code>条件时会走<code>mount</code>,其代码逻辑如下:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> mount时：根据tag不同，创建不同的Fiber节点<br>switch (workInProgress.tag) &#123;<br>  case IndeterminateComponent: <br>    <span class="hljs-regexp">//</span> ...省略<br>  case LazyComponent: <br>    <span class="hljs-regexp">//</span> ...省略<br>  case FunctionComponent: <br>    <span class="hljs-regexp">//</span> ...省略<br>  case ClassComponent: <br>    <span class="hljs-regexp">//</span> ...省略<br>  case HostRoot:<br>    <span class="hljs-regexp">//</span> ...省略<br>  case HostComponent:<br>    <span class="hljs-regexp">//</span> ...省略<br>  case HostText:<br>    <span class="hljs-regexp">//</span> ...省略<br>  <span class="hljs-regexp">//</span> ...省略其他类型<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于常见的组件类型，如（FunctionComponent/ClassComponent/HostComponent），最终会进入<code>reconcileChildren</code>方法。  </p>
<p><strong>reconcileChildren</strong>  </p>
<p><code>reconcileChildren</code>是<code>Reconciler（协调器）</code>最核心的方法，它主要做了以下工作：  </p>
<ul>
<li>1.对于<code>mount</code>的组件，创建新的子<code>Fiber</code>节点</li>
<li>2.对于<code>update</code>的组件,会使用Diff算法对比当前的Fiber和上次更新的Fiber节点，通过比较的结果生成新的Fiber节点</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">export <span class="hljs-keyword">function</span> reconcileChildren(<br>  <span class="hljs-keyword">current</span>: Fiber | <span class="hljs-keyword">null</span>,<br>  workInProgress: Fiber,<br>  nextChildren: <span class="hljs-keyword">any</span>,<br>  renderLanes: Lanes<br>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">current</span> === <span class="hljs-keyword">null</span>) &#123;<br>    // 对于mount的组件<br>    workInProgress.child = mountChildFibers(<br>      workInProgress,<br>      <span class="hljs-keyword">null</span>,<br>      nextChildren,<br>      renderLanes,<br>    );<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    // 对于<span class="hljs-keyword">update</span>的组件<br>    workInProgress.child = reconcileChildFibers(<br>      workInProgress,<br>      <span class="hljs-keyword">current</span>.child,<br>      nextChildren,<br>      renderLanes,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>跟beginWork一样，reconcileChildren也是通过current === null ?区分mount与update。  </p>
<p>不论走哪个逻辑，最终他会生成新的子Fiber节点并赋值给workInProgress.child，作为本次beginWork返回值 (opens new window)，并作为下次performUnitOfWork执行时workInProgress的传参 (opens new window)。  </p>
<p>reconcileChildFibers会为生成的Fiber节点带上effectTag属性。</p>
<p><strong>effectTag</strong>  </p>
<p>上面<code>Reconciler</code>的<code>render阶段</code>是在内存中进行的，当这个工作完成之后，会通知<code>Renderer</code>去执行真正的DOM操作，而执行DOM操作的具体类型就保存在fiber.effectTag中。exp:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima">// DOM需要插入到页面中<br>export const Placement = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b00000000000010</span>;<br>// DOM需要更新<br>export const Update = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b00000000000100</span>;<br>// DOM需要插入到页面中并更新<br>export const PlacementAndUpdate = <span class="hljs-comment">/*       */</span> <span class="hljs-number">0b00000000000110</span>;<br>// DOM需要删除<br>export const Deletion = <span class="hljs-comment">/*                 */</span> <span class="hljs-number">0b00000000001000</span>;<br></code></pre></td></tr></table></figure>
<p>那么，如果要通知Renderer将Fiber节点对应的DOM节点插入页面中，需要满足两个条件：</p>
<blockquote>
<p>1.fiber.stateNode存在，即Fiber节点中保存了对应的DOM节点<br>2.(fiber.effectTag &amp; Placement) !== 0，即Fiber节点存在Placement effectTag</p>
</blockquote>
<p>我们知道，mount时，fiber.stateNode === null，且在reconcileChildren中调用的mountChildFibers不会为Fiber节点赋值effectTag。那么首屏渲染如何完成呢？</p>
<p>针对第一个问题，fiber.stateNode会在completeWork中创建，我们会在下一节介绍。</p>
<p>第二个问题的答案十分巧妙：假设mountChildFibers也会赋值effectTag，那么可以预见mount时整棵Fiber树所有节点都会有Placement effectTag。那么commit阶段在执行DOM操作时每个节点都会执行一次插入操作，这样大量的DOM操作是极低效的。</p>
<p>为了解决这个问题，在mount时只有rootFiber会赋值Placement effectTag，在commit阶段只会执行一次插入操作。</p>
<p><strong>beginWork流程图</strong></p>
<p><img src="/2021/11/01/React原理源码学习心得/beginWork.png" srcset="/img/loading.gif" lazyload title="beginWork流程图"></p>
<h4 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h4><p>上面讲了，render阶段会经历beginWork与completeWork这两部分工作，组件执行beginWork后会创建子Fiber节点，节点上可能存在effectTag，接下来看看completeWork做什么工作吧。<br>可以先看看<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L673">completeWork 源码</a>。<br>部分代码如下：  </p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">completeWork</span></span>(<br>  current: <span class="hljs-type">Fiber </span>| <span class="hljs-literal">null</span>,<br>  workInProgress: <span class="hljs-type">Fiber</span>,<br>  renderLanes: <span class="hljs-type">Lanes</span>,<br>): <span class="hljs-type">Fiber </span>| <span class="hljs-literal">null</span> &#123;<br>  const <span class="hljs-keyword">new</span><span class="hljs-type">Props</span> = workInProgress.pendingProps;<br><br>  <span class="hljs-keyword">switch</span> (workInProgress.tag) &#123;<br>    <span class="hljs-keyword">case</span> IndeterminateComponent:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> LazyComponent:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> SimpleMemoComponent:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> FunctionComponent:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> ForwardRef:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> Fragment:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> Mode:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> Profiler:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> ContextConsumer:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> MemoComponent:<span class="hljs-type"></span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">case</span> ClassComponent: <span class="hljs-type"></span>&#123;<br>      <span class="hljs-comment">// ...省略</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> HostRoot: <span class="hljs-type"></span>&#123;<br>      <span class="hljs-comment">// ...省略</span><br>      updateHostContainer(workInProgress);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> HostComponent: <span class="hljs-type"></span>&#123;<br>      <span class="hljs-comment">// ...省略</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  <span class="hljs-comment">// ...省略</span><br></code></pre></td></tr></table></figure>

<p>其中HostComponent是原生DOM组件对应的Fiber节点。  </p>
<p><strong>处理HostComponent</strong>  </p>
<p>和beginWork一样，还是根据current === null 判断是mount还是update。</p>
<p>但是如果是update还需要考虑workInProgress.stateNode != null（即该Fiber节点是否存在对应的DOM节点）</p>
<p><strong>update</strong>  </p>
<p>如果是 update ，Fiber节点已经存在对应DOM节点，所以不需要生成DOM节点。需要做的主要是处理props，比如：</p>
<ul>
<li>onClick、onChange等回调函数的注册</li>
<li>处理style prop</li>
<li>处理DANGEROUSLY_SET_INNER_HTML prop</li>
<li>处理children prop  </li>
</ul>
<p>最主要的逻辑是调用updateHostComponent方法。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">current</span> !== <span class="hljs-keyword">null</span> &amp;&amp; workInProgress.stateNode != <span class="hljs-keyword">null</span>) &#123;<br>  // <span class="hljs-keyword">update</span>的情况<br>  updateHostComponent(<br>    <span class="hljs-keyword">current</span>,<br>    workInProgress,<br>    <span class="hljs-keyword">type</span>,<br>    newProps,<br>    rootContainerInstance,<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在updateHostComponent内部，被处理完的props会被赋值给workInProgress.updateQueue，并最终会在commit阶段被渲染在页面上。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">workInProgress.updateQueue</span> = (updatePayload: any)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><strong>mount</strong></p>
<p>mount时的主要逻辑包括三个：</p>
<ul>
<li>为Fiber节点生成对应的DOM节点</li>
<li>将子孙DOM节点插入刚生成的DOM节点中</li>
<li>与update逻辑中的updateHostComponent类似的处理props的过程</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// mount的情况</span><br><br><span class="hljs-comment">// ...省略服务端渲染相关逻辑</span><br><br><span class="hljs-keyword">const</span> currentHostContext = getHostContext();<br><span class="hljs-comment">// 为fiber创建对应DOM节点</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">instance</span> = createInstance(<br>    <span class="hljs-keyword">type</span>,<br>    newProps,<br>    rootContainerInstance,<br>    currentHostContext,<br>    workInProgress,<br>  );<br><span class="hljs-comment">// 将子孙DOM节点插入刚生成的DOM节点中</span><br>appendAllChildren(<span class="hljs-keyword">instance</span>, workInProgress, false, false);<br><span class="hljs-comment">// DOM节点赋值给fiber.stateNode</span><br>workInProgress<span class="hljs-variable">.stateNode</span> = <span class="hljs-keyword">instance</span>;<br><br><span class="hljs-comment">// 与update逻辑中的updateHostComponent类似的处理props的过程</span><br><span class="hljs-keyword">if</span> (<br>  finalizeInitialChildren(<br>    <span class="hljs-keyword">instance</span>,<br>    <span class="hljs-keyword">type</span>,<br>    newProps,<br>    rootContainerInstance,<br>    currentHostContext,<br>  )<br>) &#123;<br>  markUpdate(workInProgress);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，render阶段全部工作完成。在performSyncWorkOnRoot函数中fiberRootNode被传递给commitRoot方法，开启commit阶段工作流程。</p>
<p><strong>effectList</strong>  </p>
<p>effectTag是commit阶段操作DOM的依据，因此在render的递归阶段，会记录这些effect，保存在effectList当中，避免做重复的操作。</p>
<p>在completeWork的上层函数completeUnitOfWork中，每个执行完completeWork且存在effectTag的Fiber节点会被保存在一条被称为effectList的单向链表中。</p>
<p>effectList中第一个Fiber节点保存在fiber.firstEffect，最后一个元素保存在fiber.lastEffect。</p>
<p>类似appendAllChildren，在“归”阶段，所有有effectTag的Fiber节点都会被追加在effectList中，最终形成一条以rootFiber.firstEffect为起点的单向链表。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl">                       nextEffect         nextEffect<br><span class="hljs-function"><span class="hljs-title">rootFiber</span>.firstEffect -----------&gt;</span> <span class="hljs-function"><span class="hljs-title">fiber</span> -----------&gt;</span> fiber<br></code></pre></td></tr></table></figure>
<p>在commit阶段只需要遍历effectList就能执行所有effect了。<br><strong>completeWork流程图</strong><br><img src="/2021/11/01/React原理源码学习心得/completeWork.png" srcset="/img/loading.gif" lazyload title="completeWork流程图"></p>
<h2 id="Commit阶段"><a href="#Commit阶段" class="headerlink" title="Commit阶段"></a>Commit阶段</h2><p>Renderer工作的阶段被称为commit阶段。commit阶段可以分为三个子阶段：</p>
<p>before mutation阶段（执行DOM操作前）</p>
<p>mutation阶段（执行DOM操作）</p>
<p>layout阶段（执行DOM操作后）</p>
<h3 id="before-mutation阶段"><a href="#before-mutation阶段" class="headerlink" title="before mutation阶段"></a>before mutation阶段</h3><p>before mutation阶段主要是遍历effectList并调用commitBeforeMutationEffects函数处理。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级</span><br>const previousLanePriority = get<span class="hljs-constructor">CurrentUpdateLanePriority()</span>;<br>set<span class="hljs-constructor">CurrentUpdateLanePriority(SyncLanePriority)</span>;<br><br><span class="hljs-comment">// 将当前上下文标记为CommitContext，作为commit阶段的标志</span><br>const prevExecutionContext = executionContext;<br>executionContext <span class="hljs-pattern-match">|= <span class="hljs-constructor">CommitContext</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 处理focus状态</span><br><span class="hljs-pattern-match">focused<span class="hljs-constructor">InstanceHandle</span> = prepare<span class="hljs-constructor">ForCommit(<span class="hljs-params">root</span>.<span class="hljs-params">containerInfo</span>)</span>;</span><br><span class="hljs-pattern-match">should<span class="hljs-constructor">FireAfterActiveInstanceBlur</span> = <span class="hljs-literal">false</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> before<span class="hljs-constructor">Mutation</span>阶段的主函数</span><br><span class="hljs-pattern-match">commit<span class="hljs-constructor">BeforeMutationEffects(<span class="hljs-params">finishedWork</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">focused<span class="hljs-constructor">InstanceHandle</span> = null;</span><br></code></pre></td></tr></table></figure>
<p>对于commitBeforeMutationEffects，先看看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitBeforeMutationEffects</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> current = nextEffect.alternate;<br><br>    <span class="hljs-keyword">if</span> (!shouldFireAfterActiveInstanceBlur &amp;&amp; focusedInstanceHandle !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// ...focus blur相关</span><br>    &#125;<br><br>    <span class="hljs-keyword">const</span> effectTag = nextEffect.effectTag;<br><br>    <span class="hljs-comment">// 调用getSnapshotBeforeUpdate</span><br>    <span class="hljs-keyword">if</span> ((effectTag &amp; Snapshot) !== NoEffect) &#123;<br>      commitBeforeMutationEffectOnFiber(current, nextEffect);<br>    &#125;<br><br>    <span class="hljs-comment">// 调度useEffect</span><br>    <span class="hljs-keyword">if</span> ((effectTag &amp; Passive) !== NoEffect) &#123;<br>      <span class="hljs-keyword">if</span> (!rootDoesHavePassiveEffects) &#123;<br>        rootDoesHavePassiveEffects = <span class="hljs-literal">true</span>;<br>        scheduleCallback(NormalSchedulerPriority, <span class="hljs-function">() =&gt;</span> &#123;<br>          flushPassiveEffects();<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>      &#125;<br>    &#125;<br>    nextEffect = nextEffect.nextEffect;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到主要分为三部分：</p>
<ul>
<li><p>1.处理DOM节点渲染/删除后的 autoFocus、blur 逻辑。</p>
</li>
<li><p>2.调用getSnapshotBeforeUpdate生命周期钩子。</p>
</li>
<li><p>3.调度useEffect。</p>
</li>
<li><p><em>getSnapshotBeforeUpdate</em>*  </p>
</li>
</ul>
<p>其中因为Stack Reconciler重构为Fiber Reconciler后，render阶段的任务可能中断/重新开始，对应的组件在render阶段的生命周期钩子（即componentWillXXX）可能触发多次。<br>为此，React提供了替代的生命周期钩子getSnapshotBeforeUpdate。</p>
<p>getSnapshotBeforeUpdate是在commit阶段内的before mutation阶段调用的，由于commit阶段是同步的，所以不会遇到多次调用的问题。  </p>
<p><strong>调度useEffect</strong>  </p>
<p>scheduleCallback方法由Scheduler模块提供，用于以某个优先级异步调度一个回调函数。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 调度useEffect<br><span class="hljs-keyword">if</span> ((effectTag &amp; Passive) !== NoEffect) &#123;<br>  <span class="hljs-keyword">if</span> (!rootDoesHavePassiveEffects) &#123;<br>    rootDoesHavePassiveEffects = <span class="hljs-literal">true</span>;<br>    scheduleCallback(NormalSchedulerPriority, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      <span class="hljs-regexp">//</span> 触发useEffect<br>      flushPassiveEffects();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>被异步调度的回调函数就是触发useEffect的方法flushPassiveEffects。  </p>
<p>如何异步调度?  </p>
<p>在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。  </p>
<p>effectList中保存了需要执行副作用的Fiber节点。其中副作用包括</p>
<ul>
<li>插入DOM节点（Placement）</li>
<li>更新DOM节点（Update）</li>
<li>删除DOM节点（Deletion）</li>
</ul>
<p>当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。</p>
<p>useEffect异步调用分为三步：</p>
<ul>
<li>1.before mutation阶段在scheduleCallback中调度flushPassiveEffects</li>
<li>2.layout阶段之后将effectList赋值给rootWithPendingPassiveEffects</li>
<li>3.scheduleCallback触发flushPassiveEffects，flushPassiveEffects内部遍历rootWithPendingPassiveEffects  </li>
</ul>
<p>useEffect异步执行的原因主要是防止同步执行时阻塞浏览器渲染。</p>
<h3 id="mutation阶段"><a href="#mutation阶段" class="headerlink" title="mutation阶段"></a>mutation阶段</h3><p>类似before mutation阶段，mutation阶段也是遍历effectList，执行函数。这里执行的是commitMutationEffects。</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs monkey">nextEffect = firstEffect;<br>do &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>      commitMutationEffects(root, renderPriorityLevel);<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">error</span>) &#123;<br>      invariant(nextEffect !== <span class="hljs-literal">null</span>, <span class="hljs-comment">&#x27;Should be working on an effect.&#x27;);</span><br>      captureCommitPhaseError(nextEffect, <span class="hljs-built_in">error</span>);<br>      nextEffect = nextEffect.nextEffect;<br>    &#125;<br>&#125; <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>
<p><strong>commitMutationEffects</strong>  </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitMutationEffects</span><span class="hljs-params">(root: FiberRoot, renderPriorityLevel)</span> </span>&#123;<br>  <span class="hljs-comment">// 遍历effectList</span><br>  <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) &#123;<br><br>    <span class="hljs-keyword">const</span> effectTag = nextEffect.effectTag;<br><br>    <span class="hljs-comment">// 根据 ContentReset effectTag重置文字节点</span><br>    <span class="hljs-keyword">if</span> (effectTag &amp; ContentReset) &#123;<br>      commitResetTextContent(nextEffect);<br>    &#125;<br><br>    <span class="hljs-comment">// 更新ref</span><br>    <span class="hljs-keyword">if</span> (effectTag &amp; Ref) &#123;<br>      <span class="hljs-keyword">const</span> current = nextEffect.alternate;<br>      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) &#123;<br>        commitDetachRef(current);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据 effectTag 分别处理</span><br>    <span class="hljs-keyword">const</span> primaryEffectTag =<br>      effectTag &amp; (Placement | Update | Deletion | Hydrating);<br>    <span class="hljs-keyword">switch</span> (primaryEffectTag) &#123;<br>      <span class="hljs-comment">// 插入DOM</span><br>      <span class="hljs-keyword">case</span> Placement: &#123;<br>        commitPlacement(nextEffect);<br>        nextEffect.effectTag &amp;= ~Placement;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">// 插入DOM 并 更新DOM</span><br>      <span class="hljs-keyword">case</span> PlacementAndUpdate: &#123;<br>        <span class="hljs-comment">// 插入</span><br>        commitPlacement(nextEffect);<br><br>        nextEffect.effectTag &amp;= ~Placement;<br><br>        <span class="hljs-comment">// 更新</span><br>        <span class="hljs-keyword">const</span> current = nextEffect.alternate;<br>        commitWork(current, nextEffect);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">// SSR</span><br>      <span class="hljs-keyword">case</span> Hydrating: &#123;<br>        nextEffect.effectTag &amp;= ~Hydrating;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">// SSR</span><br>      <span class="hljs-keyword">case</span> HydratingAndUpdate: &#123;<br>        nextEffect.effectTag &amp;= ~Hydrating;<br><br>        <span class="hljs-keyword">const</span> current = nextEffect.alternate;<br>        commitWork(current, nextEffect);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">// 更新DOM</span><br>      <span class="hljs-keyword">case</span> Update: &#123;<br>        <span class="hljs-keyword">const</span> current = nextEffect.alternate;<br>        commitWork(current, nextEffect);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">// 删除DOM</span><br>      <span class="hljs-keyword">case</span> Deletion: &#123;<br>        commitDeletion(root, nextEffect, renderPriorityLevel);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br><br>    nextEffect = nextEffect.nextEffect;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从代码中路由看出，commitMutationEffects会遍历effectList，对每个Fiber节点执行如下三个操作：</p>
<ul>
<li>1.根据ContentReset effectTag重置文字节点</li>
<li>2.更新ref</li>
<li>3.根据effectTag分别处理，其中effectTag包括(Placement（插入） | Update（更新） | Deletion（删除） | Hydrating（服务端渲染）)  </li>
<li><em>Placement effect</em>*</li>
</ul>
<p>当Fiber节点含有Placement effectTag，调用commitPlacement该Fiber节点对应的DOM节点需要插入到页面中。</p>
<p>commitPlacement的方法主要分为三步：</p>
<ul>
<li>1.获取父级DOM节点<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> <span class="hljs-keyword">parent</span>Fiber = getHostParentFiber(finishedWork);  // 父级DOM节点  <span class="hljs-keyword">const</span> <span class="hljs-keyword">parent</span>StateNode = <span class="hljs-keyword">parent</span>Fiber.<span class="hljs-keyword">state</span>Node;<br></code></pre></td></tr></table></figure>
finishedWork为传入的Fiber节点</li>
<li>2.获取Fiber节点的DOM兄弟节点<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> <span class="hljs-keyword">before</span> = <span class="hljs-title">getHostSibling</span>(finishedWork);<br></code></pre></td></tr></table></figure></li>
<li>3.根据DOM兄弟节点是否存在决定调用parentNode.insertBefore或parentNode.appendChild执行DOM插入操作。  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-comment">// parentStateNode是否是rootFiber</span><br><span class="hljs-keyword">if</span> (isContainer) &#123;<br>insert<span class="hljs-constructor">OrAppendPlacementNodeIntoContainer(<span class="hljs-params">finishedWork</span>, <span class="hljs-params">before</span>, <span class="hljs-params">parent</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>insert<span class="hljs-constructor">OrAppendPlacementNode(<span class="hljs-params">finishedWork</span>, <span class="hljs-params">before</span>, <span class="hljs-params">parent</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>Update effect</strong></p>
<p>当Fiber节点含有Update effectTag，调用commitWork根据Fiber.tag分别处理。</p>
<p>对于FunctionComponent，也就是当fiber.tag为FunctionComponent，会调用commitHookEffectListUnmount。该方法会遍历effectList，执行所有useLayoutEffect hook的销毁函数。</p>
<p>对于HostComponent，fiber.tag为HostComponent（原生html标签），会调用commitUpdate。  </p>
<p>最终会在updateDOMProperties (opens new window)中将render阶段 completeWork (opens new window)中为Fiber节点赋值的updateQueue对应的内容渲染在页面上。</p>
<p><strong>Deletion effect</strong>  </p>
<p>当Fiber节点含有Deletion effectTag，会调用commitDeletion，把对应的DOM删除。 </p>
<p>commitDeletion主要执行以下操作：</p>
<ul>
<li> 递归调用Fiber节点及其子孙Fiber节点中fiber.tag为ClassComponent的componentWillUnmount (opens new window)生命周期钩子，从页面移除Fiber节点对应DOM节点</li>
<li>解绑ref</li>
<li>调度useEffect的销毁函数</li>
</ul>
<h3 id="layout-阶段"><a href="#layout-阶段" class="headerlink" title="layout 阶段"></a>layout 阶段</h3><p>layout阶段也是遍历effectList，执行commitLayoutEffects函数。  </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">root.current = finishedWork;<br><br>nextEffect = firstEffect;<br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    commit<span class="hljs-constructor">LayoutEffects(<span class="hljs-params">root</span>, <span class="hljs-params">lanes</span>)</span>;<br>  &#125; catch (error) &#123;<br>    invariant(nextEffect !== null, <span class="hljs-string">&quot;Should be working on an effect.&quot;</span>);<br>    capture<span class="hljs-constructor">CommitPhaseError(<span class="hljs-params">nextEffect</span>, <span class="hljs-params">error</span>)</span>;<br>    nextEffect = nextEffect.nextEffect;<br>  &#125;<br>&#125; <span class="hljs-keyword">while</span> (nextEffect !== null);<br><br>nextEffect = null;<br></code></pre></td></tr></table></figure>
<p><strong>commitLayoutEffects</strong>  </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> commit<span class="hljs-constructor">LayoutEffects(<span class="hljs-params">root</span>: FiberRoot, <span class="hljs-params">committedLanes</span>: Lanes)</span> &#123;<br>  <span class="hljs-keyword">while</span> (nextEffect !== null) &#123;<br>    const effectTag = nextEffect.effectTag;<br><br>    <span class="hljs-comment">// 调用生命周期钩子和hook</span><br>    <span class="hljs-keyword">if</span> (effectTag &amp; (Update <span class="hljs-pattern-match">| <span class="hljs-constructor">Callback</span>)) &#123;</span><br><span class="hljs-pattern-match">      const current = next<span class="hljs-constructor">Effect</span>.alternate;</span><br><span class="hljs-pattern-match">      commit<span class="hljs-constructor">LayoutEffectOnFiber(<span class="hljs-params">root</span>, <span class="hljs-params">current</span>, <span class="hljs-params">nextEffect</span>, <span class="hljs-params">committedLanes</span>)</span>;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 赋值<span class="hljs-built_in">ref</span></span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">if</span> (effect<span class="hljs-constructor">Tag</span> &amp; <span class="hljs-constructor">Ref</span>) &#123;</span><br><span class="hljs-pattern-match">      commit<span class="hljs-constructor">AttachRef(<span class="hljs-params">nextEffect</span>)</span>;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    next<span class="hljs-constructor">Effect</span> = next<span class="hljs-constructor">Effect</span>.next<span class="hljs-constructor">Effect</span>;</span><br><span class="hljs-pattern-match">  &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure>

<p>从代码中可以看到就做了两件事：</p>
<ul>
<li><p>1.commitLayoutEffectOnFiber（调用生命周期钩子和hook相关操作）</p>
</li>
<li><p>2.commitAttachRef（赋值 ref）</p>
</li>
</ul>
<p><strong>commitLayoutEffectOnFiber</strong></p>
<p>commitLayoutEffectOnFiber方法会根据fiber.tag对不同类型的节点分别处理。</p>
<ul>
<li>对于ClassComponent，他会通过current === null?区分是mount还是update，调用componentDidMount 或componentDidUpdate。</li>
<li>触发状态更新的this.setState如果赋值了第二个参数回调函数，也会在此时调用。<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">this</span>.setState(&#123; xxx: <span class="hljs-number">1</span> &#125;, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;i am update~&quot;</span>);<br>  &#125;);<span class="hljs-regexp">//</span> 立马打印i am update~<br></code></pre></td></tr></table></figure></li>
<li>对于FunctionComponent及相关类型，他会调用useLayoutEffect hook的回调函数，调度useEffect的销毁与回调函数。<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">switch</span> (finishedWork.tag) &#123;<br>  <span class="hljs-comment">// 以下都是FunctionComponent及相关类型</span><br>  <span class="hljs-keyword">case</span> FunctionComponent:<br>  <span class="hljs-keyword">case</span> ForwardRef:<br>  <span class="hljs-keyword">case</span> SimpleMemoComponent:<br>  <span class="hljs-keyword">case</span> Block: &#123;<br>    <span class="hljs-comment">// 执行useLayoutEffect的回调函数</span><br>    commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);<br>    <span class="hljs-comment">// 调度useEffect的销毁函数与回调函数</span><br>    schedulePassiveEffects(finishedWork);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>mutation阶段会执行useLayoutEffect hook的销毁函数。</p>
<p>结合这里我们可以发现，useLayoutEffect hook从上一次更新的销毁函数调用到本次更新的回调函数调用是同步执行的。</p>
<p>而useEffect则需要先调度，在Layout阶段完成后再异步执行。</p>
<p>以上useLayoutEffect与useEffect的区别。</p>
<p>对于HostRoot，即rootFiber，如果赋值了第三个参数回调函数，也会在此时调用。</p>
<p>即ReactDom.render函数的第三个参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#root&quot;</span>), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;i am mount~&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>commitAttachRef</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">function <span class="hljs-title">commitAttachRef</span>(<span class="hljs-params">finishedWork: Fiber</span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ref</span> = finishedWork.<span class="hljs-keyword">ref</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">ref</span> !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> instance = finishedWork.stateNode;<br><br>    <span class="hljs-comment">// 获取DOM实例</span><br>    <span class="hljs-keyword">let</span> instanceToUse;<br>    <span class="hljs-keyword">switch</span> (finishedWork.tag) &#123;<br>      <span class="hljs-keyword">case</span> HostComponent:<br>        instanceToUse = getPublicInstance(instance);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-literal">default</span>:<br>        instanceToUse = instance;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">ref</span> === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-comment">// 如果ref是函数形式，调用回调函数</span><br>      <span class="hljs-keyword">ref</span>(instanceToUse);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果ref是ref实例形式，赋值ref.current</span><br>      <span class="hljs-keyword">ref</span>.current = instanceToUse;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很显然，就是做了获取DOM实例，更新ref的操作。</p>
<p><strong>current Fiber树切换</strong></p>
<p>在layout之前会执行<code>root.current = finishedWork</code></p>
<p>componentWillUnmount会在mutation阶段执行。此时current Fiber树还指向前一次更新的Fiber树，在生命周期钩子内获取的DOM还是更新前的。</p>
<p>componentDidMount和componentDidUpdate会在layout阶段执行。此时current Fiber树已经指向更新后的Fiber树，在生命周期钩子内获取的DOM就是更新后的。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a>
                    
                      <a class="hover-with-bg" href="/tags/React/">React</a>
                    
                      <a class="hover-with-bg" href="/tags/React%E6%BA%90%E7%A0%81/">React源码</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/05/%E5%85%B3%E4%BA%8EDiff%E7%AE%97%E6%B3%95-React%E5%8E%9F%E7%90%86%E7%B3%BB%E5%88%97/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">关于Diff算法--React原理系列</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/01/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E6%B5%81%E5%A4%84%E7%90%86-%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">
                        <span class="hidden-mobile">前端文件流处理--工作经验分享</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
