<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>为了学习Promise我手写了一个PromiseA+并实现了所以静态方法......--再学JavaScript系列</title>
    <link href="/2021/03/10/%E5%86%8D%E5%AD%A6JavaScript%E7%B3%BB%E5%88%97-%E6%89%8B%E5%86%99PromiseA/"/>
    <url>/2021/03/10/%E5%86%8D%E5%AD%A6JavaScript%E7%B3%BB%E5%88%97-%E6%89%8B%E5%86%99PromiseA/</url>
    
    <content type="html"><![CDATA[<p><code>Promise</code>作为<code>JavaScript</code>异步编程最重要的知识之一，对其深入探讨非常有必要，即使你在工作中肯定不会自己去手写实现<code>Promise</code>（<del>是滴，为了装逼</del>），阅读本文你将了解<code>Promise</code>的实现细节，以及一些静态方法（包括<code>all</code> <code>race</code> <code>any</code> <code>allSettled</code>）的实现。<br>本文采用<code>ES6 class</code>语法实现，并且在阅读本文之前请确保对异步、以及<code>JavaScript</code>的事件循环机制（<code>event loop</code>）有一定了解。</p><span id="more"></span><h2 id="什么是Promise-A"><a href="#什么是Promise-A" class="headerlink" title="什么是Promise A+"></a>什么是Promise A+</h2><p><code>Promise A+</code>是一种规范，具体可见 <a href="https://promisesaplus.com/">Promise A+ 规范</a></p><h2 id="手写具体实现"><a href="#手写具体实现" class="headerlink" title="手写具体实现"></a>手写具体实现</h2><h3 id="1-Promise状态"><a href="#1-Promise状态" class="headerlink" title="1.Promise状态"></a>1.Promise状态</h3><p>据A+规范固定，一个<code>Promise</code>只能可能以下三种状态之一:<br><code>pending</code>：<code>Promise</code>的初始状态，表示等待，可以改变至<code>fulfilled</code>或者<code>rejected</code><br><code>fulfilled</code>：<code>Promise</code>的完成状态，表示成功，状态不可再改变，拥有一个<code>value</code>值，并且会执行成功的回调函数（<code>then</code>方法的第一个参数）<br><code>rejected</code>： <code>Promise</code>的拒绝状态，表示失败，状态同样不可再改变，拥有一个<code>reason</code>值，并且会执行失败的回调函数（<code>then</code>方法的第二个参数，以及<code>catch</code>方法的参数）<br>状态变化如下图：<br><img src="/2021/03/10/再学JavaScript系列-手写PromiseA/promsie%E7%8A%B6%E6%80%81%E6%9C%BA.png" title="promise状态机"><br>所以我们先定义好这三个状态的私有变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> states = &#123;<br>    pending: <span class="hljs-built_in">Symbol</span>(),<br>    fulfilled: <span class="hljs-built_in">Symbol</span>(),<br>    rejected: <span class="hljs-built_in">Symbol</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里用symbol有个好处，就是能消除魔术字符串，当然也可以用这种:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;pending&#x27;</span><br></code></pre></td></tr></table></figure><p>我在实际项目中习惯使用前者</p><h3 id="2-模拟异步"><a href="#2-模拟异步" class="headerlink" title="2.模拟异步"></a>2.模拟异步</h3><p>总所周知在<code>JavaScript</code>api里<code>Promise</code>是异步微任务，注：promiseA+没有规定怎么实现，这里我们可以模拟一下（其实还可以用<code>node</code><br>中的<code>queueMicrotask</code>）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">const</span> asyncFn = (() =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (process &amp;&amp; process.nextTick) <span class="hljs-keyword">return</span> process.nextTick<br>    <span class="hljs-keyword">return</span> setTimeout<br>&#125;)()<br><br></code></pre></td></tr></table></figure><h3 id="3-myPromise类编写"><a href="#3-myPromise类编写" class="headerlink" title="3.myPromise类编写"></a>3.myPromise类编写</h3><p>这里我们用ES6的Class语法来实现，当然也可以直接原型链上写  </p><h3 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4.构造函数"></a>4.构造函数</h3><p><code>Promise</code>构造函数接受一个参数，并具有初始状态<code>pending</code>，并且当这个函数抛出异常时返回一个失败的<code>Promise</code>,除此之外，这个函数有两个参数：第一个是将状态改变为<code>fulfilled</code>的<code>resolve</code>，第二个是将状态改变为<code>rejected</code>的<code>reject</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myPromise</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(initCallback) &#123;<br><br>        <span class="hljs-comment">// 初始化promise</span><br>        <span class="hljs-keyword">this</span>.state = states.pending<br>        <span class="hljs-keyword">this</span>.value = undefined<br>        <span class="hljs-keyword">this</span>.reason = undefined<br><br>        <span class="hljs-comment">// 用两个数组去存储成功和失败的回调，以便成功失败后调用</span><br>        <span class="hljs-keyword">this</span>.fulfilledCbStack = []<br>        <span class="hljs-keyword">this</span>.rejectedCbStack = []<br><br>        <span class="hljs-comment">// initCallback的resolve参数</span><br>        <span class="hljs-keyword">const</span> resolve = (value) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === states.pending) &#123;<br>                <span class="hljs-keyword">this</span>.state = states.fulfilled<br>                <span class="hljs-keyword">this</span>.value = value<br>                <span class="hljs-comment">// 这里forEach的参数是个箭头函数因此我们可以直接.call绑定this，否则需要将this保存并在forEach的费箭头函数中绑定上callback并执行，reject同理</span><br>                <span class="hljs-keyword">this</span>.fulfilledCbStack.forEach((cb) =&gt; cb.call(<span class="hljs-keyword">this</span>))<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// initCallback的reject参数</span><br>        <span class="hljs-keyword">const</span> reject = (reason) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === states.pending) &#123;<br>                <span class="hljs-keyword">this</span>.state = states.rejected<br>                <span class="hljs-keyword">this</span>.reason = reason<br>                <span class="hljs-keyword">this</span>.rejectedCbStack.forEach((cb) =&gt; cb.call(<span class="hljs-keyword">this</span>))<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 执行构造回调函数</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            initCallback(resolve, reject)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            reject(e)<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里说一下细节<br>首先是为什么要初始化两个数组去存储回调函数，其实是为了当一个<code>Promise</code>传入了多个then回调函数能够确保全部执行。比如我们看看以下这种情况：  </p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(res)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>        res(<span class="hljs-number">0</span>)<br>    &#125;,<span class="hljs-number">3000</span>)<br>&#125;)<br>p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(v)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cb1&#x27;</span>,v+<span class="hljs-number">1</span>)<br>&#125;)<br>p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(v)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cb2&#x27;</span>,v+<span class="hljs-number">2</span>)<br>&#125;)<br>p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(v)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cb3&#x27;</span>,v+<span class="hljs-number">3</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ <span class="hljs-keyword">node</span> <span class="hljs-title">./index</span>.js<br>cb1 <span class="hljs-number">1</span><br>cb2 <span class="hljs-number">2</span><br>cb3 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>在<code>resolve</code> <code>reject</code> 方法中改变<code>promise</code>的状态并且执行缓存的<code>callback</code>。 </p><p>执行构造函数的函数参数时需要去捕获异常，并且在捕获到异常时执行 <code>reject（）</code>函数。</p><p>写到这里其实大家可以打印下<code>Promise</code>实例中的状态，以及是否成功缓存<code>callback</code>，以及在生成<code>Promise</code>实例时抛出异常是否捕获以及返回正确的<code>Promise</code>对象。</p><h3 id="5-then方法"><a href="#5-then方法" class="headerlink" title="5.then方法"></a>5.then方法</h3><p><code>then</code>方法或者说官方A+文档所说的<code>thenable</code>方法，这是<code>Promise</code>非常关键以及重要的方法，是核心逻辑之一.  </p><p><code>then</code>方法有两个可选参数，分别是成功的回调和失败的回调，<code>then</code>方法会返回一个<code>Promise</code>。</p><p>A+文档描述如下：  </p><ul><li><code>Promise</code>必须提供一个then方法来访问当前或最终的值或原因,<code>Promise</code>的then方法接受俩个参数：<code>Promise.then(onFulfilled, onRejected)</code>。</li><li>onFulfilled和onRejected都是可选的参数。<ul><li>如果onFulfilled是一个函数,必须在<code>Promise</code>被解决后调用，<code>Promise</code>的值作为它的第一个参数,一定不能在<code>Promise</code>被解决前调用,一定不能被调用多次。</li><li>如果<code>onRejected</code>是一个函数,必须在<code>Promise</code>被拒绝之后调用，用<code>Promise</code>的原因作为它的第一个参数,一定不能在<code>Promise</code>被拒绝之前调用,一定不能被调用多次。</li></ul></li><li>在执行上下文栈中只包含平台代码之前，<code>onFulfilled</code>或<code>onRejected</code>一定不能被调用。</li><li><code>onFulfilled</code>和<code>onRejected</code>一定被作为函数调用(没有<code>this</code>值)</li><li>同一个<code>Promise</code>上的<code>then</code>可能被调用多次。<ul><li>如果<code>Promise</code>被解决，所有相应的<code>onFulfilled</code>回调必须按照他们原始调用<code>then</code>的顺序执行</li><li>如果<code>Promise</code>被拒绝，所有相应的<code>onRejected</code>回调必须按照他们原始调用<code>then</code>的顺序执行</li></ul></li><li><code>then</code>必须返回一个<code>Promise</code></li></ul><p>这里笔者其实写了两个版本，但是后来遇到了一些问题之后(漏掉了A+文档的2.3部分)重看了A+以及一些网上的正确实现写了第二个版本，我们先来看看第一个版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resCallback, rejCallback</span>)</span> &#123;<br><br>    <span class="hljs-comment">// 因为then方法参数没有规定类型，这里需要做简单处理</span><br>    resCallback = resCallback <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> ? resCallback : <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v<br>    rejCallback = rejCallback <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> ? rejCallback : <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">throw</span> e<br>    &#125;<br><br>    <span class="hljs-comment">// 根据A+规定 then方法一定返回一个新的Promise 这里我们二话不说先返回一个新的Promise</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br><br>        <span class="hljs-comment">// 成功的handleCb逻辑</span><br>        <span class="hljs-keyword">const</span> handleFulfilledCb = <span class="hljs-function">() =&gt;</span> &#123;<br>            asyncFn(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">const</span> newValue = resCallback(<span class="hljs-built_in">this</span>.value)<br>                    res(newValue)<br>                &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                    rej(e)<br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-comment">// 失败的handleCb逻辑</span><br>        <span class="hljs-keyword">const</span> handleRejectedCb = <span class="hljs-function">() =&gt;</span> &#123;<br>            asyncFn(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">const</span> newValue = rejCallback(<span class="hljs-built_in">this</span>.reason)<br>                    res(newValue)<br>                &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                    rej(e)<br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-comment">// 根据当前promise状态执行不同逻辑</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.pending) &#123;<br>            <span class="hljs-comment">// 如果是pending把callback缓存</span><br>            <span class="hljs-built_in">this</span>.fulfilledCbStack.push(handleFulfilledCb)<br>            <span class="hljs-built_in">this</span>.rejectedCbStack.push(handleRejectedCb)<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.fulfilled) &#123;<br>            <span class="hljs-comment">// 如果是fulfilled执行成功的方法</span><br>            <span class="hljs-keyword">return</span> handleFulfilledCb()<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.rejected) &#123;<br>            <span class="hljs-comment">// 如果是rejected执行失败的方法</span><br>            <span class="hljs-keyword">return</span> handleRejectedCb()<br>        &#125;<br><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码比较长，主要的细节都在注释里说明了，我们来看看还存在上面问题。  </p><p>看一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>    res(<span class="hljs-number">0</span>)<br>&#125;);<br><span class="hljs-keyword">const</span> p2 = p1.then(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> p2<br>&#125;)<br></code></pre></td></tr></table></figure><p>运行发现：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># ninthworld @ 192 in ~/my_space/demo [23:55:42] </span><br>$ <span class="hljs-keyword">node</span> <span class="hljs-title">./index</span>.js<br><br><span class="hljs-comment"># ninthworld @ 192 in ~/my_space/demo [23:56:12] </span><br>$ <br></code></pre></td></tr></table></figure><p>什么都没发生，是的因为这里发生了循环引用！这个promise永远都不可能完成，并且我们把上面的代码换成<code>Promise</code>也就是<code>JavaScript</code>本身的<code>Promise</code>api，执行结果如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ node ./index.js<br>(node:<span class="hljs-number">38662</span>) UnhandledPromiseRejectionWarning: TypeError: Chaining cycle detected <span class="hljs-keyword">for</span> promise <span class="hljs-comment">#&lt;Promise&gt;</span><br>(node:<span class="hljs-number">38662</span>) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="hljs-keyword">function</span> without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https:<span class="hljs-regexp">//</span>nodejs.org<span class="hljs-regexp">/api/</span>cli.html<span class="hljs-comment">#cli_unhandled_rejections_mode). (rejection id: 1)</span><br>(node:<span class="hljs-number">38662</span>) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero <span class="hljs-keyword">exit</span> code.<br></code></pre></td></tr></table></figure><p>是的，报错了。于是我去翻看A+文档其中有<code>2.2.7</code>有以下规定：<br><code>onFulfilled</code> 或 <code>onRejected</code> 返回一个值 x, 执行 <code>Promise Resolution Procedure    [Resolve]</code>。  </p><p>关于这个<code>Promise Resolution Procedure</code> A+文档中有很长一段解释，总结一下就是对于then的各种返回值做处理：  </p><ol><li>如果 promise and x 是同一个引用<ul><li>promise.reject(TypeError)</li></ul></li><li>如果 x 是一个 promise<ul><li>x 是 pending 的时候  <ul><li>promise 等待 x resolve 或者 reject。</li></ul></li><li>x 是 fulfilled 的时候  <ul><li>promise.resolve(x.value)  </li></ul></li><li>x 是 rejected 的时候  <ul><li>promise._reject(x.reason)    </li></ul></li></ul></li><li>x 是一个 object 或者一个 function  <ul><li>如果 x.then 存在，then = x.then</li><li>如果在得到 x.then 的值的过程中报错，promise reject 这个错误</li></ul></li><li>x 既不是 Object 和 function，也不是 Promise<ul><li>promise._resolve(x)</li></ul></li></ol><p>那么了解了以上的规则之后我们来这个<code>Promise Resolution Procedure</code>吧 </p><h3 id="6-编写Promise-Resolution-Procedure"><a href="#6-编写Promise-Resolution-Procedure" class="headerlink" title="6.编写Promise Resolution Procedure"></a>6.编写Promise Resolution Procedure</h3><p>这里说明下，<code>Promise Resolution Procedure</code>是一个私有方法，但是遗憾的是<code>JavaScript</code>这门语言并不支持<code>private</code>关键字，因此我们可以把这个方法声明在类外，做一个伪私有而不让实例，以及类上能主动调用。下面是具体代码：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> resolvePromise = <span class="hljs-function">(<span class="hljs-params">p, x, res, rej</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 处理循环引用</span><br>  <span class="hljs-keyword">if</span> (p === x) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Chaining cycle detected for promise&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 如果是myPromise直接调用then方法</span><br>  <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> myPromise) <span class="hljs-keyword">return</span> x.then(res, rej)<br><br>  <span class="hljs-comment">// 处理thenable引用数据，即含有then的数据</span><br>  <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>    <span class="hljs-comment">// then 用来访问x上的then called顾名思义，标记是否已经调用过</span><br>    <span class="hljs-keyword">let</span> then, called<br>    <span class="hljs-keyword">try</span> &#123;<br>      then = x.then<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-comment">// 处理访问then出错</span><br>      <span class="hljs-keyword">return</span> rej(e)<br>    &#125;<br>    <span class="hljs-comment">// 如果then是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        then.call(x, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) </span>&#123;<br>          <span class="hljs-keyword">if</span> (!called) &#123;<br>            called = <span class="hljs-literal">true</span><br>            resolvePromise(p, y, res, rej)<br>          &#125;<br>        &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">r</span>) </span>&#123;<br>          <span class="hljs-keyword">if</span> (!called) &#123;<br>            called = <span class="hljs-literal">true</span><br>            rej(r)<br>          &#125;<br>        &#125;)<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-keyword">if</span> (!called) &#123;<br>          rej(e)<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res(x)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res(x)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并把<code>then</code>方法部分代码重写：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resCallback, rejCallback</span>)</span> &#123;<br>  <br>  <span class="hljs-comment">// 因为then方法参数没有规定类型，这里需要做简单处理</span><br>  resCallback = resCallback <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> ? resCallback : <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v<br>  rejCallback = rejCallback <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> ? rejCallback : <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> e<br>  &#125;<br><br>  <span class="hljs-comment">// 根据A+规定 then方法一定返回一个新的Promise 这里我们二话不说先返回一个新的Promise</span><br>  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br><br>    <span class="hljs-comment">// 成功的handleCb逻辑</span><br>    <span class="hljs-keyword">const</span> handleFulfilledCb = <span class="hljs-function">() =&gt;</span> &#123;<br>      asyncFn(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> x = resCallback(<span class="hljs-built_in">this</span>.value)<br>          resolvePromise(p, x, res, rej)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          rej(e)<br>        &#125;<br>      &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 失败的handleCb逻辑</span><br>    <span class="hljs-keyword">const</span> handleRejectedCb = <span class="hljs-function">() =&gt;</span> &#123;<br>      asyncFn(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> x = rejCallback(<span class="hljs-built_in">this</span>.reason)<br>          resolvePromise(p, x, res, rej)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          rej(e)<br>        &#125;<br>      &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 根据当前promise状态执行不同逻辑</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.pending) &#123;<br>      <span class="hljs-comment">// 如果是pending把callback缓存</span><br>      <span class="hljs-built_in">this</span>.fulfilledCbStack.push(handleFulfilledCb)<br>      <span class="hljs-built_in">this</span>.rejectedCbStack.push(handleRejectedCb)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.fulfilled) &#123;<br>      <span class="hljs-comment">// 如果是fulfilled执行成功的方法</span><br>      <span class="hljs-keyword">return</span> handleFulfilledCb()<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.rejected) &#123;<br>      <span class="hljs-comment">// 如果是rejected执行失败的方法</span><br>      <span class="hljs-keyword">return</span> handleRejectedCb()<br>    &#125;<br><br>  &#125;)<br>  <span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><p>构函数处的<code>resolve</code>方法也用<code>Promise Resolution Procedure</code>去处理:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> initCallback的resolve参数<br>const resolve = <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>  resolvePromise(<span class="hljs-built_in">this</span>, value, <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.pending) &#123;<br>      <span class="hljs-built_in">this</span>.state = states.fulfilled<br>      <span class="hljs-built_in">this</span>.value = value<br>      <span class="hljs-regexp">//</span> 这里forEach的参数是个箭头函数因此我们可以直接.call绑定<span class="hljs-built_in">this</span>，否则需要将<span class="hljs-built_in">this</span>保存并在forEach的费箭头函数中绑定上callback并执行，reject同理<br>      <span class="hljs-built_in">this</span>.fulfilledCbStack.forEach(<span class="hljs-function"><span class="hljs-params">(cb)</span> =&gt;</span> cb.call(<span class="hljs-built_in">this</span>))<br>    &#125;<br>  &#125;, reject)<br>&#125;<br></code></pre></td></tr></table></figure><p>并且加上catch方法的实现(其实就是<code>then</code>方法的语法糖)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">catch</span> (cb_catch) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, cb_catch)<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，手写<code>Promise A+</code>部分的全部工作就完成啦！</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>先安装<code>promises-aplus-tests</code>这个测试库  </p><p>测试代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myPromise.deferred = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> result = &#123;&#125;;<br>  result.promise = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    result.resolve = resolve;<br>    result.reject = reject;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = myPromise;<br></code></pre></td></tr></table></figure><p>测试结果:<br><img src="/2021/03/10/再学JavaScript系列-手写PromiseA/promise%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" title="A+测试结果"><br>大功告成！872个测试用例都完美通过，成就感满满！</p><h2 id="Promise的静态方法"><a href="#Promise的静态方法" class="headerlink" title="Promise的静态方法"></a>Promise的静态方法</h2><p>经过上面的锻炼，我们对<code>Promise</code>已经有了比较深入的了解，接下来可以对<code>Promise</code>进行一些拓展实现,其实几乎所有的API都是基于<code>then</code>方法去做拓展。</p><h3 id="Promise-resolve-和-Promise-reject"><a href="#Promise-resolve-和-Promise-reject" class="headerlink" title="Promise.resolve 和 Promise.reject"></a>Promise.resolve 和 Promise.reject</h3><p>这两个API其实都比较简单,<code>Promise.resolve</code>返回一个成功的<code>Promise</code>,<code>Promise.reject</code>返回一个失败的<code>Promise</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> myPromise) <span class="hljs-keyword">return</span> value<br>  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> &amp;&amp; value.then <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>      value.then(res, rej)<br>    &#125;)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    res(value)<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">value</span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">_, rej</span>) =&gt;</span> &#123;<br>    rej(value)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>没太多可说的。</p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p><code>Promise.all</code>是非常常用的API，它接受一个数组参数，并返回一个<code>Promise</code>,当数组中每一个任务都<code>fulfilled</code>时,这个<code>Promise</code>状态为<code>fulfilled</code>,并且按顺序把每一个<code>Promise</code>的<code>value</code>存在一个数组上并返回,一旦其中一个<code>Promise</code>被<code>reject</code>，则这个返回的<code>Promise</code>也被<code>reject</code>。<br>ps： <code>Promise.all</code>是并行的，并且被<code>reject</code>之后，不会打断其他<code>Promise</code>的执行，其他的<code>Promise</code>照常执行,但是获取不到<code>value</code>。<br>下面是代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">all</span>(<span class="hljs-params">promiseList</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> resCount = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> resList = []<br>      promiseList.forEach(<span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 处理非Promise参数</span><br>        <span class="hljs-keyword">const</span> p = item <span class="hljs-keyword">instanceof</span> myPromise ? item : <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          res(item)<br>        &#125;)<br>        p.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          resList[i] = value<br>          resCount++<br>          <span class="hljs-comment">// 判断是否全部执行成功</span><br>          <span class="hljs-keyword">if</span> (resCount === promiseList.length) res(resList)<br>        &#125;)<br>        p.catch(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          rej(value)<br>        &#125;)<br>      &#125;)<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">static race(promiseList) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">(res, rej)</span> =&gt;</span> &#123;<br>    promiseList.forEach(<span class="hljs-function"><span class="hljs-params">(item)</span> =&gt;</span> &#123;<br>      const p = item <span class="hljs-keyword">instanceof</span> myPromise ? item : <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>        res(item)<br>      &#125;)<br>      p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>        res(value)<br>      &#125;)<br>      p.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>        rej(value)<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">static allSettled(promiseList) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>    let resList = []<br>    promiseList.forEach(<span class="hljs-function"><span class="hljs-params">(item, i)</span> =&gt;</span> &#123;<br>      const p = item <span class="hljs-keyword">instanceof</span> myPromise ? item : <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>        res(item)<br>      &#125;)<br>      p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>        resList[i] = &#123;<br>          status: <span class="hljs-string">&#x27;fulfilled&#x27;</span>,<br>          value<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resList.flat().length === promiseList.length) res(resList)<br>      &#125;)<br>      p.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;<br>        resList[i] = &#123;<br>          status: <span class="hljs-string">&#x27;rejected&#x27;</span>,<br>          reason<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resList.flat().length === promiseList.length) res(resList)<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">static any(promiseList) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">(res, rej)</span> =&gt;</span> &#123;<br>    let resList = <span class="hljs-keyword">new</span> AggregateError()<br>    promiseList.forEach(<span class="hljs-function"><span class="hljs-params">(item, i)</span> =&gt;</span> &#123;<br>      const p = item <span class="hljs-keyword">instanceof</span> myPromise ? item : <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>        res(item)<br>      &#125;)<br>      p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>        res(value)<br>      &#125;)<br>      p.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>        resList[i] = value<br>        <span class="hljs-keyword">if</span> (resList.flat().length === promiseList.length) rej(resList)<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Promise</code>作为<code>JavaScript</code>最常用异步解决方案之一，其实原理并不复杂，但是也有非常多的细节，不过这里仍然要提一下，不同浏览器不同的引擎对于Promise的实现可能不同，会有不同的优化。通过手写一个<code>Promise</code>，以及各种静态方法，可以非常好的提升我们对于<code>Promise</code>的理解，以及一些静态方法的理解和使用。<br>PS: 由于没有跑对<code>Promise</code>静态方法的测试包，本文只进行了简单的测试，可能会存在对于一些特殊情况运行出错，欢迎联系我交流指正！</p>]]></content>
    
    
    <categories>
      
      <category>技术探讨</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Promise</tag>
      
      <tag>异步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前同事跟我说js的值类型数据不是存在栈里WTF？值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？--再学JavaScript系列</title>
    <link href="/2021/02/23/%E5%86%8D%E5%AD%A6JavaScript%E7%B3%BB%E5%88%97-%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%B7%9F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%9C%A8%E6%A0%88%E4%B8%8A%E9%9D%A2%E4%B8%8A%E4%B8%80%E5%AE%9A%E6%AD%A3%E7%A1%AE%E5%90%97%EF%BC%9F/"/>
    <url>/2021/02/23/%E5%86%8D%E5%AD%A6JavaScript%E7%B3%BB%E5%88%97-%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%B7%9F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%9C%A8%E6%A0%88%E4%B8%8A%E9%9D%A2%E4%B8%8A%E4%B8%80%E5%AE%9A%E6%AD%A3%E7%A1%AE%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>跟前同事讨论技术，他跟我说JS的值类型不是存在栈里，于是我去学习探讨了一波。本文将分析造成引用类型跟值类型的行为差异的底层原因，V8堆栈模型浅析，以及对一些数据类型的存储机制解析。</p><span id="more"></span><h2 id="值类型和引用类型的特点"><a href="#值类型和引用类型的特点" class="headerlink" title="值类型和引用类型的特点"></a>值类型和引用类型的特点</h2><p>根据JS的定义，或者说ECMAScript的定义总共有八种语言类型：<code>null</code>,<code>undefined</code>,<code>number</code>,<code>boolean</code>,<code>string</code>,<code>symbol</code>,<code>bigint</code>,<code>object</code><br>其中除了 <code>object</code> 其他都是值类型，我们用一段代码来概括其区别:  </p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = a;<br><span class="hljs-attr">a</span> = <span class="hljs-number">2</span> <br>console.log(b); // <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span> = &#123;x: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">d</span> = c;<br>c.<span class="hljs-attr">x</span> = <span class="hljs-number">2</span><br>console.log(c.x); // <span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">e</span> = <span class="hljs-number">2</span> <br><span class="hljs-keyword">let</span> <span class="hljs-attr">f</span> = <span class="hljs-number">2</span><br><span class="hljs-attr">e</span> === f // <span class="hljs-literal">true</span> <br><span class="hljs-keyword">let</span> <span class="hljs-attr">g</span> = &#123;x: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">h</span> = &#123;x: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-attr">g</span> === h // <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="数据在堆栈中的存储"><a href="#数据在堆栈中的存储" class="headerlink" title="数据在堆栈中的存储"></a>数据在堆栈中的存储</h2><p>对于以上现象，先用通俗的解释：<br>对于值类型，其在内存中存储在一个栈当中其中key是变量名，value是具体的值。因此<code>b = a</code>成立因为value完全一致嘛。<br>而对于引用类型，<code>let c = &#123;x: 1&#125;</code> 这行代码先在堆上面开辟一块内存空间,其中存储着 <code>&#123;x:1&#125;</code>这条数据，然后对于变量<code>c</code>其value中存储着这个空间的地址，因此<code>d = c</code>的赋值操作其实是复制了一份地址，而不是数据，二者都指向堆里面的<code>&#123;x: 1&#125;</code>数据，因此当修改二者其中之一时，另一个变量随之改变。对于<code>g</code>跟<code>h</code>两个变量，二者虽然数据一摸一样，但是二者不是同一块内存空间，修改<code>g</code>中的<code>x：1</code>不会改变<code>h</code>中的<code>x</code>因此不相等。<br>图解如下：<br><img src="/2021/02/23/再学JavaScript系列-值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？/srack&heap.jpg" title="堆栈"></p><h2 id="堆栈的空间结构"><a href="#堆栈的空间结构" class="headerlink" title="堆栈的空间结构"></a>堆栈的空间结构</h2><p>栈的空间结构没什么好讲的，就是一块连续的存储空间，再看看堆的存储结构张图:<br><img src="/2021/02/23/再学JavaScript系列-值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？/heap.jpg" title="堆内存结构"><br>其中：  </p><ul><li><p>新生代内存区（new space）<br>新生代内存区会被划分为两个semispace，每个semispace大小默认为16MB也就是说新生代内存区通常只有32MB大小（64位），而这两个semispace分别是from space 和 to space（具体有什么用下文会说），通常新创建的对象会先放入这两个semispace中的一个。</p></li><li><p>老生代内存区（old space）<br>通常会较为持久的保存对象,也分为两个区域 old pointer space 和 old data space分别用来存放GC后还存活的指针信息和数据信息。</p></li><li><p>大对象区（large object space）<br>这里存放体积超越其他区大小的对象，主要为了避免大对象的拷贝，使用该空间专门存储大对象。</p></li><li><p>单元区、属性单元区、Map区（Cell space、property cell space、map space）<br>Map空间存放对象的Map信息也就是隐藏类(Hiden Class）最大限制为8MB；每个Map对象固定大小，为了快速定位，所以将该空间单独出来。</p></li><li><p>代码区 (code Space)<br>主要存放代码对象，最大限制为512MB，也是唯一拥有执行权限的内存</p></li></ul><h2 id="V8引擎中的基本类型存储机制"><a href="#V8引擎中的基本类型存储机制" class="headerlink" title="V8引擎中的基本类型存储机制"></a>V8引擎中的基本类型存储机制</h2><h3 id="一个疑点"><a href="#一个疑点" class="headerlink" title="一个疑点"></a>一个疑点</h3><p>根据上文所说，对于基本类型应该是存储在栈中的，但是V8引擎中一个栈区的大小为984kib 理论上一个字符串的大小不会超过这个数字，但是实际操作中却能声明一个上百mib大小的字符串，如图：  </p><p><img src="/2021/02/23/再学JavaScript系列-值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？/bigString.jpeg" title="堆内存结构"></p><h3 id="V8引擎string的真正存储机制"><a href="#V8引擎string的真正存储机制" class="headerlink" title="V8引擎string的真正存储机制"></a>V8引擎<code>string</code>的真正存储机制</h3><p>因此实际的V8引擎中数据绝不仅仅是简单的栈存储。<br>先说结论，实际上对于 <code>string</code>，先从内存中（哈希表）查找是否有已经创建的完全一致的字符串，如果存在，直接复用。如果不存在，则开辟一块新的内存空间存进这个字符串，然后把地址赋到变量中。同时，这也解释了为啥V8里字符串不能通过下标修改字符串，因为人家本来就是不可变的。<br>我们直接来看一下一段V8的源码验证下： </p><p><img src="/2021/02/23/再学JavaScript系列-值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？/stringTable.png" title="V8 StringTable源码"><br><img src="/2021/02/23/再学JavaScript系列-值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？/getName.jpeg" title="V8 StringTable源码"><br><img src="/2021/02/23/再学JavaScript系列-值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？/newString.jpeg" title="V8 StringTable源码"></p><p>因此其实我们声明两个相同的字符串时，两个变量的地址（hash）其实是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> BasicVarGen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.s0 = <span class="hljs-string">&#x27;IAmString&#x27;</span><br>    <span class="hljs-built_in">this</span>.s1 = <span class="hljs-string">&#x27;IAmString&#x27;</span><br>&#125;<br><br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> BasicVarGen()<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> BasicVarGen()<br><span class="hljs-comment">//a b中的s0 s1是同一个内存地址（hash）</span><br></code></pre></td></tr></table></figure><h3 id="V8引擎number的存储机制"><a href="#V8引擎number的存储机制" class="headerlink" title="V8引擎number的存储机制"></a>V8引擎<code>number</code>的存储机制</h3><p><code>number</code>在V8中分为 <code>smi</code> 和 <code>heapNumber</code>,<br><code>smi</code> 直接存进内存,范围为 ： -2³¹ 到 2³¹-1（2³¹≈2*10⁹）的整数<br><code>heapNumber</code> 类似字符串,不可变,范围为 ：所有非smi的数字，存进堆里面  </p><p>ECMAScript 标准约定number数字需要被当成 64 位双精度浮点数处理，由于一直使用 64 位去存储任何数字实际是非常低效的（空间低效，计算时间低效 smi大量使用位运算），所以 JavaScript 引擎并不总会使用 64 位去存储数字，引擎在内部可以采用其他内存表示方式（如 32 位），只要保证数字外部所有能被监测到的特性对齐 64 位的表现就行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>值类型跟引用类型在实际使用中需要注意一些使用上的差异，这种差异根据JavaScript引擎会有不同的实现，在V8中并不是所有的值类型都存储在栈内存中，对于V8引擎来说:  </p><ul><li><p><code>string</code>： 存在堆里，栈中为引用地址，如果存在相同字符串，则引用地址相同。</p></li><li><p><code>number</code>： 小整数存在栈中，其他类型存在堆中。</p></li><li><p>其他类型：引擎初始化时分配唯一地址，栈中的变量存的是唯一的引用。</p></li></ul><p>(参考链接：<a href="https://juejin.cn/post/6844904175868837901">https://juejin.cn/post/6844904175868837901</a>)<br>(参考链接：<a href="https://www.zhihu.com/question/482433315/answer/2083349992?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1118537826173702144&amp;utm_content=group1_Answer&amp;utm_campaign=shareopn">https://www.zhihu.com/question/482433315/answer/2083349992?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1118537826173702144&amp;utm_content=group1_Answer&amp;utm_campaign=shareopn</a>)</p>]]></content>
    
    
    <categories>
      
      <category>技术探讨</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>V8</tag>
      
      <tag>堆栈模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记--《JavaScript教程》《JavaScript高级程序设计》关键知识点笔记</title>
    <link href="/2020/09/23/JavaScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/09/23/JavaScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>此篇是博主在阅读这两本JavaScript入门书籍时记得一些笔记，以及一些知识点，长期更新，文中有错误欢迎指正，有不同理解欢迎交流。</p><span id="more"></span><h2 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一.数据类型"></a>一.数据类型</h2><p>在es5之前总共有：<em>null</em> <em>undefined</em> <em>boolean</em> <em>object</em> <em>string</em> <em>number</em> 六种数据类型，es6新增了 <em>symbol</em> ,es11新增了 <em>bigint</em> </p><p>所以截止es2021，目前总共有：<em>null</em> <em>undefined</em> <em>boolean</em> <em>object</em> <em>string</em> <em>number</em> <em>symbol</em> <em>bigint</em> 基本数据类型</p><p>ps：这些也是 <code>typeof</code> 能返回的所有值</p><h3 id="原始类型和引用类型"><a href="#原始类型和引用类型" class="headerlink" title="原始类型和引用类型"></a>原始类型和引用类型</h3><p>一版来说JavaScript的数据类型分为两大类，原始类型和引用类型，其中<em>null</em> <em>undefined</em> <em>boolean</em> <em>number</em> <em>symbol</em> <em>bigint</em> <em>string</em> 都是基本数据类型。<br>基本数据类型中除了<code>null</code> 跟 <code>undefined</code> 都有包装对象，在你调用这些基本类型的属性跟方法的时候其实就是创建了一个临时的包装对象，然后执行对应的属性跟方法，执行完之后就销毁。<br>值得一提的是虽然 <code>symbol</code> 跟 <code>bigint</code> 有包装对象但是没有构造函数，所以使用 <code>new</code> 操作会报错。</p><h3 id="数据类型判断的三个原生方法"><a href="#数据类型判断的三个原生方法" class="headerlink" title="数据类型判断的三个原生方法"></a>数据类型判断的三个原生方法</h3><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.<code>typeof</code></h4><p>数值、字符串、布尔值分别返回number、string、boolean，函数返回function，undefined返回undefined，对象返回object，null返回object。</p><p>ps：<code>typeof null // object</code> 其实是历史原因,1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。</p><h4 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.<code>instanceof</code></h4><p><code>instanceof</code> 运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p><p><code>instanceof</code> 是基于原型链查找，运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const v = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vehicle()</span><br>v instanceof Vehicle<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vehicle</span>.</span></span>prototype.is<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">v</span>)</span><br></code></pre></td></tr></table></figure><h4 id="3-Object-prototype-toString"><a href="#3-Object-prototype-toString" class="headerlink" title="3.Object.prototype.toString"></a>3.<code>Object.prototype.toString</code></h4><p>因为大部分数据类型都自定义重写了toString方法，一次可以根据此方法的返回值去判断数据类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript">数值：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Number</span>]。<br>字符串：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">String</span>]。<br>布尔值：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Boolean</span>]。<br><span class="hljs-literal">undefined</span>：返回[<span class="hljs-built_in">object</span> Undefined]。<br><span class="hljs-literal">null</span>：返回[<span class="hljs-built_in">object</span> Null]。<br>数组：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Array</span>]。<br><span class="hljs-built_in">arguments</span> 对象：返回[<span class="hljs-built_in">object</span> Arguments]。<br>函数：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Function</span>]。<br><span class="hljs-built_in">Error</span> 对象：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Error</span>]。<br><span class="hljs-built_in">Date</span> 对象：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Date</span>]。<br><span class="hljs-built_in">RegExp</span> 对象：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">RegExp</span>]。<br>其他对象：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Object</span>]。<br>symbol对象：返回<span class="hljs-built_in">Symbol</span>()<br></code></pre></td></tr></table></figure><h2 id="二-运算符"><a href="#二-运算符" class="headerlink" title="二.运算符"></a>二.运算符</h2><p>加法运算符：<code>x + y</code><br>减法运算符： <code>x - y</code><br>乘法运算符： <code>x * y</code><br>除法运算符：<code>x / y</code><br>指数运算符：<code>x ** y</code><br>余数运算符：<code>x % y</code><br>自增运算符：<code>++x 或者 x++</code><br>自减运算符：<code>--x 或者 x--</code><br>数值运算符： <code>+x</code><br>负数值运算符：<code>-x</code>  </p><h3 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符 +"></a>加法运算符 <code>+</code></h3><p>上面这些运算符号值得说的其实就是 <code>+</code> 运算符，加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。<br>比如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>+ true // <span class="hljs-number">2</span><br><span class="hljs-comment">&#x27;3&#x27; + 4 + 5 // &quot;345&quot;</span><br><span class="hljs-symbol">3 </span>+ <span class="hljs-number">4</span> + <span class="hljs-comment">&#x27;5&#x27; // &quot;75&quot;</span><br></code></pre></td></tr></table></figure><h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符 **"></a>指数运算符 <code>**</code></h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>** <span class="hljs-number">4</span> // <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>指数运算符需要注意的是，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 相当于 <span class="hljs-number">2</span> ** (<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>)<br> <span class="hljs-number">2</span> ** <span class="hljs-number">3</span> ** <span class="hljs-number">2</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">512</span><br></code></pre></td></tr></table></figure><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><p>布尔运算符就以下四种：  </p><ul><li>取反运算符：<code>!</code></li><li>且运算符：<code>&amp;&amp;</code></li><li>或运算符：<code>||</code></li><li>三元运算符：<code>?:</code></li></ul><h4 id="1-取反运算符："><a href="#1-取反运算符：" class="headerlink" title="1.取反运算符：!"></a>1.取反运算符：<code>!</code></h4><p><code>!</code>运算符会把布尔值变成相反值，值得注意的是也能对非布尔值取反，只要记住以下取反是<code>true</code>其他都是<code>false</code>:  </p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>false</code></li><li><code>0</code></li><li><code>NaN</code></li><li><code>&#39;&#39;</code></li></ul><p>小tips：对一个变量两次取反就是把变量变成对应的<code>boolean</code>值，相当于<code>Boolean()</code>方法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">!!x<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-title">Boolean</span><span class="hljs-params">(x)</span></span><br></code></pre></td></tr></table></figure><h4 id="2-且运算符：-amp-amp"><a href="#2-且运算符：-amp-amp" class="headerlink" title="2.且运算符：&amp;&amp;"></a>2.且运算符：<code>&amp;&amp;</code></h4><p>它的运算规则是：如果第一个运算子的布尔值为 <code>true</code>，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为 <code>false</code>，则直接返回第一个运算子的值，且不再对第二个运算子求值。<br>ps：经常拿来代替 <code>if</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (i) &#123;<br>  <span class="hljs-selector-tag">doSomething</span>();<br>&#125;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-tag">&amp;</span> <span class="hljs-selector-tag">doSomething</span>();<br></code></pre></td></tr></table></figure><h4 id="3-或运算符："><a href="#3-或运算符：" class="headerlink" title="3.或运算符：||"></a>3.或运算符：<code>||</code></h4><p>它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。<br>ps：经常拿来设置一个变量的默认值</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>() || <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="4-三元运算符："><a href="#4-三元运算符：" class="headerlink" title="4.三元运算符：?:"></a>4.三元运算符：<code>?:</code></h4><p>三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。<br>ps: 经常拿来代替if else 非常的简便好用,而且具有返回值</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> isBoy = sex===<span class="hljs-string">&#x27;男&#x27;</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>二进制位运算符用于直接对二进制位进行计算，一共有7个。</p><ul><li>二进制或运算符（or）：符号为<code>|</code>，表示若两个二进制位都为0，则结果为0，否则为1。</li><li>二进制与运算符（and）：符号为<code>&amp;</code>，表示若两个二进制位都为1，则结果为1，否则为0。</li><li>二进制否运算符（not）：符号为<code>~</code>，表示对一个二进制位取反。</li><li>异或运算符（xor）：符号为<code>^</code>，表示若两个二进制位不相同，则结果为1，否则为0。</li><li>左移运算符（left shift）：符号为<code>&lt;&lt;</code>。</li><li>右移运算符（right shift）：符号为<code>&gt;&gt;</code>。</li><li>头部补零的右移运算符（zero filled right shift）：符号为<code>&gt;&gt;&gt;</code>。</li></ul><p>有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。</p><p>前四个根据上面的字面意思自己理解，这里写一些比较有意思的位运算操作:  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 把i转成成一个整数<br>i = i | <span class="hljs-number">0</span> <br><br><span class="hljs-regexp">//</span> 不依赖第三个变量交换ab的值<br>var a = <span class="hljs-number">10</span>;<br>var b = <span class="hljs-number">99</span>;<br>a ^= b, b ^= a, a ^= b;<br>a <span class="hljs-regexp">//</span> <span class="hljs-number">99</span><br>b <span class="hljs-regexp">//</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h4 id="左移运算符-lt-lt"><a href="#左移运算符-lt-lt" class="headerlink" title="左移运算符 &lt;&lt;"></a>左移运算符 <code>&lt;&lt;</code></h4><p>左移运算符（&lt;&lt;）表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方。向左移动的时候，最高位的符号位是一起移动的。</p><h4 id="右移运算符-gt-gt"><a href="#右移运算符-gt-gt" class="headerlink" title="右移运算符 &gt;&gt;"></a>右移运算符 <code>&gt;&gt;</code></h4><p>右移运算符（&gt;&gt;）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补0；如果是负数，头部全部补1。右移运算符基本上相当于除以2的指定次方（最高位即符号位参与移动）。</p><h4 id="左移运算符-gt-gt-gt"><a href="#左移运算符-gt-gt-gt" class="headerlink" title="左移运算符 &gt;&gt;&gt;"></a>左移运算符 <code>&gt;&gt;&gt;</code></h4><p>头部补零的右移运算符（&gt;&gt;&gt;）与右移运算符（&gt;&gt;）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（&gt;&gt;）完全一致，区别主要在于负数。<br>查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">-<span class="hljs-number">1</span> &gt;&gt;&gt; <span class="hljs-number">0</span> <span class="hljs-regexp">//</span> <span class="hljs-number">4294967295</span><br></code></pre></td></tr></table></figure><h2 id="JavaScript类型转换"><a href="#JavaScript类型转换" class="headerlink" title="JavaScript类型转换"></a>JavaScript类型转换</h2><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>1.<code>Number()</code>  </p><p>对于基本类型直接转换，对于对象：  </p><p>第一步，调用对象自身的<code>valueOf</code>方法。如果返回原始类型的值，则直接对该值使用<code>Number</code>函数，不再进行后续步骤。  </p><p>第二步，如果<code>valueOf</code>方法返回的还是对象，则改为调用对象自身的<code>toString</code>方法。如果<code>toString</code>方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。</p><p>第三步，如果<code>toString</code>方法返回的是对象，就报错。  </p><p><code>Number()</code> 比 <code>parseInt</code>严哥很多，只要有一个字没法转换成数值就会转成NaN  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">parseInt</span><span class="hljs-params">(<span class="hljs-string">&#x27;42 cats&#x27;</span>)</span></span> <span class="hljs-comment">// 42</span><br><span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(<span class="hljs-string">&#x27;42 cats&#x27;</span>)</span></span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>2.<code>String()</code>  </p><p>与``Number<code>基本相同，只是先执行</code>toString<code>，结果不符合再执行 </code>valueOf`  </p><p>3.<code>Boolean()</code>  </p><p>除了以下五个转换为<code>false</code>，其他所以值都是<code>true</code> 甚至包括 <code>false</code> 的包装对象  </p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>0（包含-0和+0）</code></li><li><code>NaN</code></li><li><code>&#39;&#39;（空字符串）</code></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Boolean</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="自动转换（隐式转换）"><a href="#自动转换（隐式转换）" class="headerlink" title="自动转换（隐式转换）"></a>自动转换（隐式转换）</h3><p>出现情况主要有以下这些情况：  </p><ul><li>不同类型的数据互相运算 <code>123 + &#39;abc&#39; // &quot;123abc&quot;</code></li><li>对非布尔值类型的数据求布尔值 <code>if(&#39;abc&#39;)</code></li><li>对非数值类型的值使用一元运算符 <code>+ &#123;foo: &#39;bar&#39;&#125; // NaN</code></li></ul><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h3><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>1.<code>Object.keys()</code> 与 <code>Object.getOwnPropertyNames()</code>  </p><p>这两个方法都是返回对像自身的属性名集合，结果是一个数组。区别是：<br>前者不会返回不可枚举的属性名，后者会。</p><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>1.<code>Object.prototype.valueOf()</code> 返回当前对象的对应值  </p><p>默认返回对象本身，在一些类型转换的情况，比如 <code>1 + obj &quot;1[object Object]&quot;</code> 时会调用这个方法，可以重写以实现一些特殊的现象。  </p><p>2.<code>Object.prototype.toString() </code> 返回当前对象对应的字符串形式  </p><p>默认返回<code>&quot;[object Object]&quot;</code>,在跟字符串做加法时会调用这个方法，并且可使用这个方法判断数据类型</p><p>3.<code>Object.prototype.toLocaleString()</code> 返回当前对象对应的本地字符串形式  </p><p><code>Object.prototype.toLocaleString</code>方法与<code>toString</code>的返回结果相同，也是返回一个值的字符串形式。<br>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的<code>toLocaleString</code>，用来返回针对某些地域的特定的值。</p><p>4.<code>Object.prototype.hasOwnProperty()</code> 判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。  </p><p>ps： 可以遍历属性的不可枚举属性</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>学习</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
