<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从React-Hooks源码解析hooks设计思想以及原理--React原码</title>
    <link href="/2021/11/29/%E4%BB%8EReact-Hooks%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90hooks%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86-React%E5%8E%9F%E7%A0%81/"/>
    <url>/2021/11/29/%E4%BB%8EReact-Hooks%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90hooks%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86-React%E5%8E%9F%E7%A0%81/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Diff算法--React原理系列</title>
    <link href="/2021/11/05/%E5%85%B3%E4%BA%8EDiff%E7%AE%97%E6%B3%95-React%E5%8E%9F%E7%90%86%E7%B3%BB%E5%88%97/"/>
    <url>/2021/11/05/%E5%85%B3%E4%BA%8EDiff%E7%AE%97%E6%B3%95-React%E5%8E%9F%E7%90%86%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><code>Diff</code>算法作为前端框架里应用非常多的技术，学习其原理非常有必要，在阅读本文之前请确保了解<code>React</code>的基础架构，因为<code>React</code>的<code>Diff</code>相比于常见用于虚拟dom树对比的<code>Diff</code>算法在细节上还是略有不同。</p><span id="more"></span><h2 id="关于传统的Diff算法为什么是O-n-3"><a href="#关于传统的Diff算法为什么是O-n-3" class="headerlink" title="关于传统的Diff算法为什么是O(n^3)?"></a>关于传统的Diff算法为什么是O(n^3)?</h2><p>首先对于两颗树来讲，如果要找到最小程度的更新，肯定需要完全对比两棵树上的每一个节点。举个例子就是：  </p><p><img src="/2021/11/05/关于Diff算法-React原理系列/%E5%AF%B9%E6%AF%94%E4%B8%A4%E6%A3%B5%E6%A0%91.png"><br>如果要对这样两棵树，遍历<code>old tree</code>的每一个子节点,对于每一个子节点，查找在<code>new tree</code>上是否存在，位置是否正确。流程大概是：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">OA-&gt;NA<br>OA-&gt;ND<br>OA-&gt;NE<br>OA-&gt;NC<br>OA-&gt;NF<br>OB-&gt;NA<br>......<br></code></pre></td></tr></table></figure><p>因此计算最小差异的时间复杂是<code>O(n^2)</code>,在计算完最小更新之后，还需要计算最小更新操作，这里可以观看一道leetCode算法<a href="https://leetcode-cn.com/problems/edit-distance/comments/">最小编辑距离</a>的题解，假设<code>old tree</code>的节点数为<code>m</code>,<code>new tree</code>为<code>n</code>的话，完成树的最小编辑距离算法复杂度其实是<code>O(n^2m(1+logmn))</code>,当<code>m=n</code>时就是<code>n^3</code>。  </p><h2 id="React的Diff为何是O-n"><a href="#React的Diff为何是O-n" class="headerlink" title="React的Diff为何是O(n)"></a>React的Diff为何是O(n)</h2><p>其实<code>React</code>并不是通过什么骚操作攻破了这一业界难题，而是做了一些取舍：</p><ul><li>1.只对同级元素进行比较，不跨级比较。</li><li>2.如果<code>tag</code>标记不同，直接删除这个子树。</li><li>3.当<code>key</code>和<code>prop</code>会被认为是同一棵树，被复用。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">  // 更新前<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;h2&quot;</span>&gt;</span>h<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>// 更新后<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;h1&quot;</span>&gt;</span>h<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>如果没有key，React会认为div的第一个子节点由p变为h3，第二个子节点由h3变为p。这符合限制2的设定，会销毁并新建。<br>但是当用key指明了节点前后对应关系后，React知道p1在更新后还存在，所以DOM节点可以复用，只是需要交换下顺序。  </li></ul><p>因此React的Diff只需要遍历一遍树即可,大大降低时间复杂度。</p><h2 id="React的Diff实现"><a href="#React的Diff实现" class="headerlink" title="React的Diff实现"></a>React的Diff实现</h2><p>从Diff的入口函数reconcileChildFibers出发看看代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 根据newChild类型选择不同diff函数处理</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildFibers</span></span>(<br>  returnFiber: <span class="hljs-type">Fiber</span>,<br>  currentFirstChild: <span class="hljs-type">Fiber </span>| <span class="hljs-literal">null</span>,<br>  <span class="hljs-keyword">new</span><span class="hljs-type">Child</span>: any,<br>): <span class="hljs-type">Fiber </span>| <span class="hljs-literal">null</span> &#123;<br><br>  const isObject = typeof <span class="hljs-keyword">new</span><span class="hljs-type">Child</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">new</span><span class="hljs-type">Child</span> !== <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">if</span> (isObject) &#123;<br>    <span class="hljs-comment">// object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span><br>    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Child</span>.$$typeof) &#123;<br>      <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE:<span class="hljs-type"></span><br>        <span class="hljs-comment">// 调用 reconcileSingleElement 处理</span><br>      <span class="hljs-comment">// // ...省略其他case</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">new</span><span class="hljs-type">Child</span> === <span class="hljs-string">&#x27;string&#x27;</span> || typeof <span class="hljs-keyword">new</span><span class="hljs-type">Child</span> === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 调用 reconcileSingleTextNode 处理</span><br>    <span class="hljs-comment">// ...省略</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (isArray(<span class="hljs-keyword">new</span><span class="hljs-type">Child</span>)) &#123;<br>    <span class="hljs-comment">// 调用 reconcileChildrenArray 处理</span><br>    <span class="hljs-comment">// ...省略</span><br>  &#125;<br><br>  <span class="hljs-comment">// 一些其他情况调用处理函数</span><br>  <span class="hljs-comment">// ...省略</span><br><br>  <span class="hljs-comment">// 以上都没有命中，删除节点</span><br>  <span class="hljs-keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中当newChild类型为object、number、string，代表同级只有一个节点，<br>当newChild类型为Array，同级有多个节点。<br>可以看到React根据每一层的节点数量将Diff分为两类。</p><h3 id="单节点Diff"><a href="#单节点Diff" class="headerlink" title="单节点Diff"></a>单节点Diff</h3><p>对于单个节点会进入<code>reconcileSingleElement</code>方法：<br>`<br>  const isObject = typeof newChild === ‘object’ &amp;&amp; newChild !== null;</p><p>  if (isObject) {<br>    // 对象类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE<br>    switch (newChild.$$typeof) {<br>      case REACT_ELEMENT_TYPE:<br>        // 调用 reconcileSingleElement 处理<br>      // …其他case<br>    }<br>  }<br>`<br>这个函数主要流程是：</p><ul><li>1.</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React原理源码系统性学习心得--React原理系列</title>
    <link href="/2021/11/01/React%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    <url>/2021/11/01/React%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<p>笔者于今年开始接触并接手React项目的研发，为了进一步学习React并了解其原理源码，笔者开始学习React的原理以及源码，主要的学习途径为一些网站(主要是卡颂大佬的<a href="https://react.iamkasong.com/">React技术揭秘</a>)，书籍，以及自己看源码等等，本文是笔者在学习React过程的笔记，以及本者本人对于React的一些理解。阅读本文前请确保你已经非常熟悉React，并且有一定的开发踩坑经验。</p><span id="more"></span><h1 id="React核心原理以及部分源码"><a href="#React核心原理以及部分源码" class="headerlink" title="React核心原理以及部分源码"></a>React核心原理以及部分源码</h1><h2 id="React哲学"><a href="#React哲学" class="headerlink" title="React哲学"></a>React哲学</h2><p>官网上对于React哲学的简介是:  </p><blockquote><p>“我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。”<br>因此对于React来说，如何构建快速响应的大型Web应用程序是核心。</p></blockquote><h3 id="React核心架构"><a href="#React核心架构" class="headerlink" title="React核心架构"></a>React核心架构</h3><p><strong>React15架构</strong>：</p><ul><li>Reconciler(协调器)<ul><li>找出变化的组件</li></ul></li><li>Renderer<ul><li>负责把变化的组件渲染到页面上  </li></ul></li></ul><p><strong>Reconciler(协调器)</strong>  </p><p>先说说React渲染原理：<br>在React中触发组件更新的操作有（不包括React Hook）：<br><code>this.setState</code>,<code>this.forceUpdate</code>,<code>ReactDOM.render</code>。<br>当有更新要发生时，Reconciler将开始工作，进行以下操作：  </p><ul><li>1.执行函数组件或执行Class Components的render方法，将返回的JSX通过React.createElement转换成虚拟DOM。</li><li>2.通过Diff算法将新旧虚拟DOM进行对比</li><li>3.通过对比得到最小更新范围</li><li>4.通知Renderer将本次的变更更新到真是DOM即页面上</li></ul><p><strong>Renderer(渲染器)</strong>  </p><p>React官方文档对于渲染器的解释是:</p><blockquote><p>渲染器用于管理一棵 React 树，使其根据底层平台进行不同的调用。  </p></blockquote><p>Renderer做的事情非常简单，就是：在每次更新发生时，Renderer接到Reconciler通知，将变化的组件渲染在当前宿主环境。<br>PS:不同平台有不同的Renderer，浏览器平台是React.DOM,RN上是ReactNative,还有ReactArt用于渲染到Canvas，SVG等</p><p><strong>缺点</strong></p><p>对于Reconciler,mount的组件会调用mountComponent，update的组件会调用updateComponent。这两个方法都会递归更新子组件。可参考源码：<a href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498">mountComponent</a>  <a href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877">updateComponent</a><br>总所周知，递归无法被中断，所以当子组件很多，递归层级很深时，会耗时非常长，而对于用户来讲，每一帧的刷新时间差不多是1６.６ms(1s/60FPS)，所以当递归更新的时间超过这个时间时，视觉上就会卡顿。<br>其实要解决这个问题就需要异步更新，但是React15当时并不支持异步更新，因此React16更新了架构。  </p><p><strong>React16架构</strong>  </p><p>React16架构中新增了Scheduler（调度器），所以新的架构分为：</p><ul><li>Scheduler（调度器）<ul><li>调度任务的优先级，高优任务优先进入Reconciler</li></ul></li><li>Reconciler（协调器）<ul><li>找出变化的组件</li></ul></li><li>Renderer（渲染器）<ul><li>负责将变化的组件渲染到页面上</li></ul></li></ul><p><strong>Scheduler（调度器）</strong>  </p><p>调度器的作用就是当浏览器有剩余时间时通知我们，因此作为任务中断的标准，除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。<br>ps: <a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md">Scheduler</a>是独立于React的库  </p><p><strong>Reconciler（协调器）</strong>  </p><p>在React16中不在是用递归去更新，而是通过可中断的循环过程，每次循环都会调用shouldYield判断当前是否有剩余时间。部分源码如下:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/** @noinline */</span><br><span class="hljs-keyword">function</span> workLoopConcurrent() &#123;<br>  // <span class="hljs-keyword">Perform</span> <span class="hljs-keyword">work</span> <span class="hljs-keyword">until</span> Scheduler asks us <span class="hljs-keyword">to</span> yield<br>  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-keyword">null</span> &amp;&amp; !shouldYield()) &#123;<br>    workInProgress = performUnitOfWork(workInProgress);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是仅此不作处理会导致，DOM渲染不完全。因此在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs maxima">export type SideEffectTag = number;<br><br>// Don&#x27;t change these two <span class="hljs-built_in">values</span>. They&#x27;re used by React Dev Tools.<br>export const NoEffect = <span class="hljs-comment">/*                     */</span> <span class="hljs-number">0b000000000000000</span>;<br>export const PerformedWork = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b000000000000001</span>;<br><br>// You can change the <span class="hljs-built_in">rest</span> (<span class="hljs-keyword">and</span> add more).<br>export const Placement = <span class="hljs-comment">/*                    */</span> <span class="hljs-number">0b000000000000010</span>;<br>export const Update = <span class="hljs-comment">/*                       */</span> <span class="hljs-number">0b000000000000100</span>;<br>export const PlacementAndUpdate = <span class="hljs-comment">/*           */</span> <span class="hljs-number">0b000000000000110</span>;<br>export const Deletion = <span class="hljs-comment">/*                     */</span> <span class="hljs-number">0b000000000001000</span>;<br>export const ContentReset = <span class="hljs-comment">/*                 */</span> <span class="hljs-number">0b000000000010000</span>;<br>export const Callback = <span class="hljs-comment">/*                     */</span> <span class="hljs-number">0b000000000100000</span>;<br>export const DidCapture = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b000000001000000</span>;<br>export const Ref = <span class="hljs-comment">/*                          */</span> <span class="hljs-number">0b000000010000000</span>;<br>export const Snapshot = <span class="hljs-comment">/*                     */</span> <span class="hljs-number">0b000000100000000</span>;<br>export const Passive = <span class="hljs-comment">/*                      */</span> <span class="hljs-number">0b000001000000000</span>;<br>export const PassiveUnmountPendingDev = <span class="hljs-comment">/*     */</span> <span class="hljs-number">0b010000000000000</span>;<br>export const Hydrating = <span class="hljs-comment">/*                    */</span> <span class="hljs-number">0b000010000000000</span>;<br>export const HydratingAndUpdate = <span class="hljs-comment">/*           */</span> <span class="hljs-number">0b000010000000100</span>;<br><br>// Passive &amp; Update &amp; Callback &amp; Ref &amp; Snapshot<br>export const LifecycleEffectMask = <span class="hljs-comment">/*          */</span> <span class="hljs-number">0b000001110100100</span>;<br><br>// Union of all host effects<br>export const HostEffectMask = <span class="hljs-comment">/*               */</span> <span class="hljs-number">0b000011111111111</span>;<br><br>// These are <span class="hljs-keyword">not</span> really side effects, but we still reuse this field.<br>export const Incomplete = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b000100000000000</span>;<br>export const ShouldCapture = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b001000000000000</span>;<br>export const ForceUpdateForLegacySuspense = <span class="hljs-comment">/* */</span> <span class="hljs-number">0b100000000000000</span>;<br><br>// Union of side effect groupings as pertains to subtreeTag<br>export const BeforeMutationMask = <span class="hljs-comment">/*           */</span> <span class="hljs-number">0b000001100001010</span>;<br>export const MutationMask = <span class="hljs-comment">/*                 */</span> <span class="hljs-number">0b000010010011110</span>;<br>export const LayoutMask = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b000000010100100</span>;<br></code></pre></td></tr></table></figure><p>只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。  </p><p><strong>Renderer（渲染器）</strong>  </p><p>Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。<br>因此，并中断的只有Scheduler通知Reconciler以及Reconciler产生虚拟DOM以及打标记的过程，并不会中断Renderer的渲染，因此不会造成不完全的DOM。  </p><h3 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h3><p>从React16开始采用了新的Reconciler，新的Reconciler采用了Fiber架构。  </p><p>如何理解Fiber？先简单做一个定义：  </p><blockquote><p>React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。  </p></blockquote><p>其中每个任务更新单元为React Element对应的Fiber节点。</p><p><strong>Fiber含义：</strong></p><ul><li>1.作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。</li><li>2.作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的DOM节点等信息。</li><li>3.作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。</li></ul><p><strong>Fiber结构：</strong><br>先来看看<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiber.new.js#L117">Fiber</a>的源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function FiberNode(<br>  tag: WorkTag,<br>  pendingProps: mixed,<br>  key: <span class="hljs-literal">null</span> | string,<br>  mode: TypeOfMode,<br>) &#123;<br>  <span class="hljs-comment">// Instance 当前节点的一些静态属性</span><br><br>  <span class="hljs-comment">// Fiber对应组件的类型 Function/Class/Host...</span><br>  <span class="hljs-keyword">this</span>.tag = tag;<br><br>  <span class="hljs-keyword">this</span>.key = key;<br>  <span class="hljs-keyword">this</span>.elementType = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName</span><br>  <span class="hljs-keyword">this</span>.type = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// Fiber对应的真实DOM节点</span><br>  <span class="hljs-keyword">this</span>.stateNode = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// Fiber  连接其他节点，形成Fiber树</span><br><br>  <span class="hljs-comment">// 指向父级Fiber节点</span><br>  <span class="hljs-keyword">this</span>.<span class="hljs-keyword">return</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 指向子Fiber节点</span><br>  <span class="hljs-keyword">this</span>.child = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 指向右边第一个兄弟Fiber节点</span><br>  <span class="hljs-keyword">this</span>.sibling = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">this</span>.index = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">this</span>.ref = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 作为调度任务的信息属性</span><br><br>  <span class="hljs-comment">// 保存本次更新造成的状态改变相关信息</span><br>  <span class="hljs-keyword">this</span>.pendingProps = pendingProps;<br>  <span class="hljs-keyword">this</span>.memoizedProps = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.updateQueue = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.memoizedState = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.dependencies = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">this</span>.mode = mode;<br><br>  <span class="hljs-comment">// Effects</span><br><br>  <span class="hljs-comment">// 保存本次更新会造成的DOM操作</span><br>  <span class="hljs-keyword">this</span>.effectTag = NoEffect;<br>  <span class="hljs-keyword">this</span>.subtreeTag = NoSubtreeEffect;<br>  <span class="hljs-keyword">this</span>.deletions = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.nextEffect = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">this</span>.firstEffect = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.lastEffect = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 调度优先级相关</span><br>  <span class="hljs-keyword">this</span>.lanes = NoLanes;<br>  <span class="hljs-keyword">this</span>.childLanes = NoLanes;<br><br>  <span class="hljs-comment">// 指向该fiber在另一次更新时对应的fiber</span><br>  <span class="hljs-keyword">this</span>.alternate = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Fiber执行机制</strong></p><p>双缓存Fiber树：  </p><p>在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。  </p><p>并且二者通过一下方式链接：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">currentFiber.alternate</span> === workInProgressFiber<span class="hljs-comment">;</span><br><span class="hljs-attr">workInProgressFiber.alternate</span> === currentFiber<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>Fiber在渲染更新中的切换机制是：</p><blockquote><p>React应用的根节点通过使current指针在不同Fiber树的rootFiber间切换来完成current Fiber树指向的切换。<br>即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。<br>每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。  </p></blockquote><p>这部细节可以看卡颂大佬的文章。</p><h2 id="JSX本质"><a href="#JSX本质" class="headerlink" title="JSX本质"></a>JSX本质</h2><p>在React中，JSX在编译时会被Babel编译为React.createElement。当然也可以指定编译为其他函数，因此并不是只有React才能使用JSX，可以通过@babel/plugin-transform-react-jsx (opens new window)插件显式告诉Babel编译时需要将JSX编译为什么函数的调用。</p><h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h3><p>先来看看代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> createElement(<span class="hljs-keyword">type</span>, <span class="hljs-keyword">config</span>, children) &#123;<br>  <span class="hljs-keyword">let</span> propName;<br><br>  <span class="hljs-keyword">const</span> props = &#123;&#125;;<br><br>  <span class="hljs-keyword">let</span> key = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">ref</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> self = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> source = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">config</span> != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 将 config 处理后赋值给 props</span><br>    <span class="hljs-comment">// ...省略</span><br>  &#125;<br><br>  <span class="hljs-keyword">const</span> childrenLength = arguments<span class="hljs-variable">.length</span> - <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// 处理 children，会被赋值给props.children</span><br>  <span class="hljs-comment">// ...省略</span><br><br>  <span class="hljs-comment">// 处理 defaultProps</span><br>  <span class="hljs-comment">// ...省略</span><br><br>  <span class="hljs-keyword">return</span> ReactElement(<br>    <span class="hljs-keyword">type</span>,<br>    key,<br>    <span class="hljs-keyword">ref</span>,<br>    self,<br>    source,<br>    ReactCurrentOwner<span class="hljs-variable">.current</span>,<br>    props,<br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> ReactElement = <span class="hljs-keyword">function</span>(<span class="hljs-keyword">type</span>, key, <span class="hljs-keyword">ref</span>, self, source, owner, props) &#123;<br>  <span class="hljs-keyword">const</span> element = &#123;<br>    <span class="hljs-comment">// 标记这是个 React Element</span><br>    $$typeof: REACT_ELEMENT_TYPE,<br><br>    <span class="hljs-keyword">type</span>: <span class="hljs-keyword">type</span>,<br>    key: key,<br>    <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">ref</span>,<br>    props: props,<br>    <span class="hljs-number">_</span>owner: owner,<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> element;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到React.createElement接受三个参数，第一个是type,一般指标签的类型，自定义组件等等，第二个是config指标签和组件上的props属性，第三个是children代表子节点，子组件。最终React.createElement返回的也就是ReactElement。  </p><p>可以看到ReactElement上是没有之前提到的Fiber的一些信息：</p><blockquote><ul><li>组件在更新中的优先级  </li><li>组件的state  </li><li>组件被打上的用于Renderer的标记  </li></ul></blockquote><p>因此，在组件mount时，Reconciler根据JSX描述的组件内容生成组件对应的Fiber节点。</p><p>在update时，Reconciler将JSX与Fiber节点保存的数据对比，生成组件对应的Fiber节点，并根据对比结果为Fiber节点打上标记。</p><h2 id="Render阶段"><a href="#Render阶段" class="headerlink" title="Render阶段"></a>Render阶段</h2><p>在render阶，如果是同步更新会调用<code>performSyncWorkOnRoot</code>,如果是异步更新则会调用<code>performConcurrentWorkOnRoot</code>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// performSyncWorkOnRoot会调用该方法</span><br><span class="hljs-keyword">function</span> work<span class="hljs-constructor">LoopSync()</span> &#123;<br>  <span class="hljs-keyword">while</span> (workInProgress !== null) &#123;<br>    perform<span class="hljs-constructor">UnitOfWork(<span class="hljs-params">workInProgress</span>)</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// performConcurrentWorkOnRoot会调用该方法</span><br><span class="hljs-keyword">function</span> work<span class="hljs-constructor">LoopConcurrent()</span> &#123;<br>  <span class="hljs-keyword">while</span> (workInProgress !== null<span class="hljs-operator"> &amp;&amp; </span>!should<span class="hljs-constructor">Yield()</span>) &#123;<br>    perform<span class="hljs-constructor">UnitOfWork(<span class="hljs-params">workInProgress</span>)</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>二者的区别只有如果是异步更新，会在其中加中断条件<code>shouldYield</code>,如果当前浏览器帧没有剩余时间，会终止循环，等到浏览器空闲时继续遍历。</p><p>workInProgress代表当前已创建的workInProgress fiber。</p><p>performUnitOfWork方法会创建下一个Fiber节点并赋值给workInProgress，并将workInProgress与已创建的Fiber节点连接起来构成Fiber树。</p><h3 id="Render流程"><a href="#Render流程" class="headerlink" title="Render流程"></a>Render流程</h3><ul><li>1.首先会从<code>rootFiber</code>开始进行深度优先遍历，对于每一个遍历的<code>Fiber</code>节点，都会调用<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058">beginWork</a>方法。  </li><li>2.<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058">beginWork</a>方法根据传入的<code>Fiber</code>节点，创建子<code>Fiber</code>节点，并且将两个节点连接起来。</li><li>3.当遍历到叶子节点，会开始执行<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652">completeWork</a>处理节点。  <ul><li>当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），则对其兄弟节点进行<code>beginWork</code>。</li><li>如果不存在兄弟Fiber，对父节点调用<code>completeWork</code>。</li><li>最终会回到<code>rootFiber</code>节点，至此整个<code>render</code>阶段就结束了  </li></ul></li></ul><h4 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h4><p>根据 <a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058">beginWork</a> 源码。<br>首先，<code>beginWork</code> 接三个参数:</p><ul><li>current：当前组件对应的Fiber节点在上一次更新时的Fiber节点，即workInProgress.alternate</li><li>workInProgress：当前组件对应的Fiber节点</li><li>renderLanes：和渲染优先级相关<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts">function beginWork(<br><span class="hljs-symbol">  current:</span> Fiber | null,<br><span class="hljs-symbol">  workInProgress:</span> Fiber,<br><span class="hljs-symbol">  renderLanes:</span> Lanes,<br>): Fiber | <span class="hljs-class">null </span>&#123;<br>  <span class="hljs-comment">// ...省略函数体</span><br>&#125;<br></code></pre></td></tr></table></figure>根据之前讲得双缓存Fiber树，假如组件是第一次<code>mount</code>那么<code>beginWork</code>的<code>current</code>参数就是<code>null</code>，因此beginWork通过判断<code>current===null</code>来区组件是<code>mount</code>还是<code>update</code>。  </li></ul><p>代码逻辑如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">function <span class="hljs-title">beginWork</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  current: Fiber | <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  workInProgress: Fiber,</span></span><br><span class="hljs-params"><span class="hljs-function">  renderLanes: Lanes</span></span><br><span class="hljs-params"><span class="hljs-function"></span>): Fiber | <span class="hljs-literal">null</span></span> &#123;<br><br>  <span class="hljs-comment">// update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）</span><br>  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// ...省略</span><br><br>    <span class="hljs-comment">// 复用current</span><br>    <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(<br>      current,<br>      workInProgress,<br>      renderLanes,<br>    );<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    didReceiveUpdate = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// mount时：根据tag不同，创建不同的子Fiber节点</span><br>  <span class="hljs-keyword">switch</span> (workInProgress.tag) &#123;<br>    <span class="hljs-keyword">case</span> IndeterminateComponent: <br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-keyword">case</span> LazyComponent: <br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-keyword">case</span> FunctionComponent: <br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-keyword">case</span> ClassComponent: <br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-keyword">case</span> HostRoot:<br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-keyword">case</span> HostComponent:<br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-keyword">case</span> HostText:<br>      <span class="hljs-comment">// ...省略</span><br>    <span class="hljs-comment">// ...省略其他类型</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以可以把beginWork的工作分为两个部分：</p><p>update时：如果current存在，且满足一定条件时，复用current节点，克隆current.child作为workInProgress.child。</p><p>mount时：除fiberRootNode以外，根据fiber.tag不同，创建不同类型的子Fiber节点。</p><p><strong>update</strong>  </p><p>update部分代码逻辑如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">current</span> !== <span class="hljs-keyword">null</span>) &#123;<br>    const oldProps = <span class="hljs-keyword">current</span>.memoizedProps;<br>    const newProps = workInProgress.pendingProps;<br><br>    <span class="hljs-keyword">if</span> (<br>      oldProps !== newProps ||<br>      hasLegacyContextChanged() ||<br>      (__DEV__ ? workInProgress.<span class="hljs-keyword">type</span> !== <span class="hljs-keyword">current</span>.<span class="hljs-keyword">type</span> : <span class="hljs-keyword">false</span>)<br>    ) &#123;<br>      didReceiveUpdate = <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!includesSomeLane(renderLanes, updateLanes)) &#123;<br>      didReceiveUpdate = <span class="hljs-keyword">false</span>;<br>      switch (workInProgress.tag) &#123;<br>        // 省略处理<br>      &#125;<br>      <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(<br>        <span class="hljs-keyword">current</span>,<br>        workInProgress,<br>        renderLanes,<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      didReceiveUpdate = <span class="hljs-keyword">false</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    didReceiveUpdate = <span class="hljs-keyword">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看到，当满足:</p><ul><li>1.<code>oldProps === newProps &amp;&amp; workInProgress.type === current.type</code> 即props与fiber.type都不变</li><li>2.<code>!includesSomeLane(renderLanes, updateLanes)</code>，即当前Fiber节点优先级不够。 </li></ul><p>如果满足上述条件，<code>didReceiveUpdate === false</code>（即可以直接复用前一次更新的子Fiber，不需要新建子Fiber）。  </p><p><strong>mount</strong>  </p><p>当不满足<code>update</code>条件时会走<code>mount</code>,其代码逻辑如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> mount时：根据tag不同，创建不同的Fiber节点<br>switch (workInProgress.tag) &#123;<br>  case IndeterminateComponent: <br>    <span class="hljs-regexp">//</span> ...省略<br>  case LazyComponent: <br>    <span class="hljs-regexp">//</span> ...省略<br>  case FunctionComponent: <br>    <span class="hljs-regexp">//</span> ...省略<br>  case ClassComponent: <br>    <span class="hljs-regexp">//</span> ...省略<br>  case HostRoot:<br>    <span class="hljs-regexp">//</span> ...省略<br>  case HostComponent:<br>    <span class="hljs-regexp">//</span> ...省略<br>  case HostText:<br>    <span class="hljs-regexp">//</span> ...省略<br>  <span class="hljs-regexp">//</span> ...省略其他类型<br>&#125;<br></code></pre></td></tr></table></figure><p>对于常见的组件类型，如（FunctionComponent/ClassComponent/HostComponent），最终会进入<code>reconcileChildren</code>方法。  </p><p><strong>reconcileChildren</strong>  </p><p><code>reconcileChildren</code>是<code>Reconciler（协调器）</code>最核心的方法，它主要做了以下工作：  </p><ul><li>1.对于<code>mount</code>的组件，创建新的子<code>Fiber</code>节点</li><li>2.对于<code>update</code>的组件,会使用Diff算法对比当前的Fiber和上次更新的Fiber节点，通过比较的结果生成新的Fiber节点</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">export <span class="hljs-keyword">function</span> reconcileChildren(<br>  <span class="hljs-keyword">current</span>: Fiber | <span class="hljs-keyword">null</span>,<br>  workInProgress: Fiber,<br>  nextChildren: <span class="hljs-keyword">any</span>,<br>  renderLanes: Lanes<br>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">current</span> === <span class="hljs-keyword">null</span>) &#123;<br>    // 对于mount的组件<br>    workInProgress.child = mountChildFibers(<br>      workInProgress,<br>      <span class="hljs-keyword">null</span>,<br>      nextChildren,<br>      renderLanes,<br>    );<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    // 对于<span class="hljs-keyword">update</span>的组件<br>    workInProgress.child = reconcileChildFibers(<br>      workInProgress,<br>      <span class="hljs-keyword">current</span>.child,<br>      nextChildren,<br>      renderLanes,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟beginWork一样，reconcileChildren也是通过current === null ?区分mount与update。  </p><p>不论走哪个逻辑，最终他会生成新的子Fiber节点并赋值给workInProgress.child，作为本次beginWork返回值 (opens new window)，并作为下次performUnitOfWork执行时workInProgress的传参 (opens new window)。  </p><p>reconcileChildFibers会为生成的Fiber节点带上effectTag属性。</p><p><strong>effectTag</strong>  </p><p>上面<code>Reconciler</code>的<code>render阶段</code>是在内存中进行的，当这个工作完成之后，会通知<code>Renderer</code>去执行真正的DOM操作，而执行DOM操作的具体类型就保存在fiber.effectTag中。exp:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima">// DOM需要插入到页面中<br>export const Placement = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b00000000000010</span>;<br>// DOM需要更新<br>export const Update = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b00000000000100</span>;<br>// DOM需要插入到页面中并更新<br>export const PlacementAndUpdate = <span class="hljs-comment">/*       */</span> <span class="hljs-number">0b00000000000110</span>;<br>// DOM需要删除<br>export const Deletion = <span class="hljs-comment">/*                 */</span> <span class="hljs-number">0b00000000001000</span>;<br></code></pre></td></tr></table></figure><p>那么，如果要通知Renderer将Fiber节点对应的DOM节点插入页面中，需要满足两个条件：</p><blockquote><p>1.fiber.stateNode存在，即Fiber节点中保存了对应的DOM节点<br>2.(fiber.effectTag &amp; Placement) !== 0，即Fiber节点存在Placement effectTag</p></blockquote><p>我们知道，mount时，fiber.stateNode === null，且在reconcileChildren中调用的mountChildFibers不会为Fiber节点赋值effectTag。那么首屏渲染如何完成呢？</p><p>针对第一个问题，fiber.stateNode会在completeWork中创建，我们会在下一节介绍。</p><p>第二个问题的答案十分巧妙：假设mountChildFibers也会赋值effectTag，那么可以预见mount时整棵Fiber树所有节点都会有Placement effectTag。那么commit阶段在执行DOM操作时每个节点都会执行一次插入操作，这样大量的DOM操作是极低效的。</p><p>为了解决这个问题，在mount时只有rootFiber会赋值Placement effectTag，在commit阶段只会执行一次插入操作。</p><p><strong>beginWork流程图</strong></p><p><img src="/2021/11/01/React原理源码学习心得/beginWork.png" title="beginWork流程图"></p><h4 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h4><p>上面讲了，render阶段会经历beginWork与completeWork这两部分工作，组件执行beginWork后会创建子Fiber节点，节点上可能存在effectTag，接下来看看completeWork做什么工作吧。<br>可以先看看<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L673">completeWork 源码</a>。<br>部分代码如下：  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">completeWork</span></span>(<br>  current: <span class="hljs-type">Fiber </span>| <span class="hljs-literal">null</span>,<br>  workInProgress: <span class="hljs-type">Fiber</span>,<br>  renderLanes: <span class="hljs-type">Lanes</span>,<br>): <span class="hljs-type">Fiber </span>| <span class="hljs-literal">null</span> &#123;<br>  const <span class="hljs-keyword">new</span><span class="hljs-type">Props</span> = workInProgress.pendingProps;<br><br>  <span class="hljs-keyword">switch</span> (workInProgress.tag) &#123;<br>    <span class="hljs-keyword">case</span> IndeterminateComponent:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> LazyComponent:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> SimpleMemoComponent:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> FunctionComponent:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> ForwardRef:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> Fragment:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> Mode:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> Profiler:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> ContextConsumer:<span class="hljs-type"></span><br>    <span class="hljs-keyword">case</span> MemoComponent:<span class="hljs-type"></span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">case</span> ClassComponent: <span class="hljs-type"></span>&#123;<br>      <span class="hljs-comment">// ...省略</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> HostRoot: <span class="hljs-type"></span>&#123;<br>      <span class="hljs-comment">// ...省略</span><br>      updateHostContainer(workInProgress);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> HostComponent: <span class="hljs-type"></span>&#123;<br>      <span class="hljs-comment">// ...省略</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  <span class="hljs-comment">// ...省略</span><br></code></pre></td></tr></table></figure><p>其中HostComponent是原生DOM组件对应的Fiber节点。  </p><p><strong>处理HostComponent</strong>  </p><p>和beginWork一样，还是根据current === null 判断是mount还是update。</p><p>但是如果是update还需要考虑workInProgress.stateNode != null（即该Fiber节点是否存在对应的DOM节点）</p><p><strong>update</strong>  </p><p>如果是 update ，Fiber节点已经存在对应DOM节点，所以不需要生成DOM节点。需要做的主要是处理props，比如：</p><ul><li>onClick、onChange等回调函数的注册</li><li>处理style prop</li><li>处理DANGEROUSLY_SET_INNER_HTML prop</li><li>处理children prop  </li></ul><p>最主要的逻辑是调用updateHostComponent方法。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">current</span> !== <span class="hljs-keyword">null</span> &amp;&amp; workInProgress.stateNode != <span class="hljs-keyword">null</span>) &#123;<br>  // <span class="hljs-keyword">update</span>的情况<br>  updateHostComponent(<br>    <span class="hljs-keyword">current</span>,<br>    workInProgress,<br>    <span class="hljs-keyword">type</span>,<br>    newProps,<br>    rootContainerInstance,<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在updateHostComponent内部，被处理完的props会被赋值给workInProgress.updateQueue，并最终会在commit阶段被渲染在页面上。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">workInProgress.updateQueue</span> = (updatePayload: any)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>mount</strong></p><p>mount时的主要逻辑包括三个：</p><ul><li>为Fiber节点生成对应的DOM节点</li><li>将子孙DOM节点插入刚生成的DOM节点中</li><li>与update逻辑中的updateHostComponent类似的处理props的过程</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// mount的情况</span><br><br><span class="hljs-comment">// ...省略服务端渲染相关逻辑</span><br><br><span class="hljs-keyword">const</span> currentHostContext = getHostContext();<br><span class="hljs-comment">// 为fiber创建对应DOM节点</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">instance</span> = createInstance(<br>    <span class="hljs-keyword">type</span>,<br>    newProps,<br>    rootContainerInstance,<br>    currentHostContext,<br>    workInProgress,<br>  );<br><span class="hljs-comment">// 将子孙DOM节点插入刚生成的DOM节点中</span><br>appendAllChildren(<span class="hljs-keyword">instance</span>, workInProgress, false, false);<br><span class="hljs-comment">// DOM节点赋值给fiber.stateNode</span><br>workInProgress<span class="hljs-variable">.stateNode</span> = <span class="hljs-keyword">instance</span>;<br><br><span class="hljs-comment">// 与update逻辑中的updateHostComponent类似的处理props的过程</span><br><span class="hljs-keyword">if</span> (<br>  finalizeInitialChildren(<br>    <span class="hljs-keyword">instance</span>,<br>    <span class="hljs-keyword">type</span>,<br>    newProps,<br>    rootContainerInstance,<br>    currentHostContext,<br>  )<br>) &#123;<br>  markUpdate(workInProgress);<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，render阶段全部工作完成。在performSyncWorkOnRoot函数中fiberRootNode被传递给commitRoot方法，开启commit阶段工作流程。</p><p><strong>effectList</strong>  </p><p>effectTag是commit阶段操作DOM的依据，因此在render的递归阶段，会记录这些effect，保存在effectList当中，避免做重复的操作。</p><p>在completeWork的上层函数completeUnitOfWork中，每个执行完completeWork且存在effectTag的Fiber节点会被保存在一条被称为effectList的单向链表中。</p><p>effectList中第一个Fiber节点保存在fiber.firstEffect，最后一个元素保存在fiber.lastEffect。</p><p>类似appendAllChildren，在“归”阶段，所有有effectTag的Fiber节点都会被追加在effectList中，最终形成一条以rootFiber.firstEffect为起点的单向链表。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl">                       nextEffect         nextEffect<br><span class="hljs-function"><span class="hljs-title">rootFiber</span>.firstEffect -----------&gt;</span> <span class="hljs-function"><span class="hljs-title">fiber</span> -----------&gt;</span> fiber<br></code></pre></td></tr></table></figure><p>在commit阶段只需要遍历effectList就能执行所有effect了。<br><strong>completeWork流程图</strong><br><img src="/2021/11/01/React原理源码学习心得/completeWork.png" title="completeWork流程图"></p><h2 id="Commit阶段"><a href="#Commit阶段" class="headerlink" title="Commit阶段"></a>Commit阶段</h2><p>Renderer工作的阶段被称为commit阶段。commit阶段可以分为三个子阶段：</p><p>before mutation阶段（执行DOM操作前）</p><p>mutation阶段（执行DOM操作）</p><p>layout阶段（执行DOM操作后）</p><h3 id="before-mutation阶段"><a href="#before-mutation阶段" class="headerlink" title="before mutation阶段"></a>before mutation阶段</h3><p>before mutation阶段主要是遍历effectList并调用commitBeforeMutationEffects函数处理。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级</span><br>const previousLanePriority = get<span class="hljs-constructor">CurrentUpdateLanePriority()</span>;<br>set<span class="hljs-constructor">CurrentUpdateLanePriority(SyncLanePriority)</span>;<br><br><span class="hljs-comment">// 将当前上下文标记为CommitContext，作为commit阶段的标志</span><br>const prevExecutionContext = executionContext;<br>executionContext <span class="hljs-pattern-match">|= <span class="hljs-constructor">CommitContext</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 处理focus状态</span><br><span class="hljs-pattern-match">focused<span class="hljs-constructor">InstanceHandle</span> = prepare<span class="hljs-constructor">ForCommit(<span class="hljs-params">root</span>.<span class="hljs-params">containerInfo</span>)</span>;</span><br><span class="hljs-pattern-match">should<span class="hljs-constructor">FireAfterActiveInstanceBlur</span> = <span class="hljs-literal">false</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> before<span class="hljs-constructor">Mutation</span>阶段的主函数</span><br><span class="hljs-pattern-match">commit<span class="hljs-constructor">BeforeMutationEffects(<span class="hljs-params">finishedWork</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">focused<span class="hljs-constructor">InstanceHandle</span> = null;</span><br></code></pre></td></tr></table></figure><p>对于commitBeforeMutationEffects，先看看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitBeforeMutationEffects</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> current = nextEffect.alternate;<br><br>    <span class="hljs-keyword">if</span> (!shouldFireAfterActiveInstanceBlur &amp;&amp; focusedInstanceHandle !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// ...focus blur相关</span><br>    &#125;<br><br>    <span class="hljs-keyword">const</span> effectTag = nextEffect.effectTag;<br><br>    <span class="hljs-comment">// 调用getSnapshotBeforeUpdate</span><br>    <span class="hljs-keyword">if</span> ((effectTag &amp; Snapshot) !== NoEffect) &#123;<br>      commitBeforeMutationEffectOnFiber(current, nextEffect);<br>    &#125;<br><br>    <span class="hljs-comment">// 调度useEffect</span><br>    <span class="hljs-keyword">if</span> ((effectTag &amp; Passive) !== NoEffect) &#123;<br>      <span class="hljs-keyword">if</span> (!rootDoesHavePassiveEffects) &#123;<br>        rootDoesHavePassiveEffects = <span class="hljs-literal">true</span>;<br>        scheduleCallback(NormalSchedulerPriority, <span class="hljs-function">() =&gt;</span> &#123;<br>          flushPassiveEffects();<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>      &#125;<br>    &#125;<br>    nextEffect = nextEffect.nextEffect;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到主要分为三部分：</p><ul><li><p>1.处理DOM节点渲染/删除后的 autoFocus、blur 逻辑。</p></li><li><p>2.调用getSnapshotBeforeUpdate生命周期钩子。</p></li><li><p>3.调度useEffect。</p></li><li><p><em>getSnapshotBeforeUpdate</em>*  </p></li></ul><p>其中因为Stack Reconciler重构为Fiber Reconciler后，render阶段的任务可能中断/重新开始，对应的组件在render阶段的生命周期钩子（即componentWillXXX）可能触发多次。<br>为此，React提供了替代的生命周期钩子getSnapshotBeforeUpdate。</p><p>getSnapshotBeforeUpdate是在commit阶段内的before mutation阶段调用的，由于commit阶段是同步的，所以不会遇到多次调用的问题。  </p><p><strong>调度useEffect</strong>  </p><p>scheduleCallback方法由Scheduler模块提供，用于以某个优先级异步调度一个回调函数。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 调度useEffect<br><span class="hljs-keyword">if</span> ((effectTag &amp; Passive) !== NoEffect) &#123;<br>  <span class="hljs-keyword">if</span> (!rootDoesHavePassiveEffects) &#123;<br>    rootDoesHavePassiveEffects = <span class="hljs-literal">true</span>;<br>    scheduleCallback(NormalSchedulerPriority, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      <span class="hljs-regexp">//</span> 触发useEffect<br>      flushPassiveEffects();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>被异步调度的回调函数就是触发useEffect的方法flushPassiveEffects。  </p><p>如何异步调度?  </p><p>在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。  </p><p>effectList中保存了需要执行副作用的Fiber节点。其中副作用包括</p><ul><li>插入DOM节点（Placement）</li><li>更新DOM节点（Update）</li><li>删除DOM节点（Deletion）</li></ul><p>当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。</p><p>useEffect异步调用分为三步：</p><ul><li>1.before mutation阶段在scheduleCallback中调度flushPassiveEffects</li><li>2.layout阶段之后将effectList赋值给rootWithPendingPassiveEffects</li><li>3.scheduleCallback触发flushPassiveEffects，flushPassiveEffects内部遍历rootWithPendingPassiveEffects  </li></ul><p>useEffect异步执行的原因主要是防止同步执行时阻塞浏览器渲染。</p><h3 id="mutation阶段"><a href="#mutation阶段" class="headerlink" title="mutation阶段"></a>mutation阶段</h3><p>类似before mutation阶段，mutation阶段也是遍历effectList，执行函数。这里执行的是commitMutationEffects。</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs monkey">nextEffect = firstEffect;<br>do &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>      commitMutationEffects(root, renderPriorityLevel);<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">error</span>) &#123;<br>      invariant(nextEffect !== <span class="hljs-literal">null</span>, <span class="hljs-comment">&#x27;Should be working on an effect.&#x27;);</span><br>      captureCommitPhaseError(nextEffect, <span class="hljs-built_in">error</span>);<br>      nextEffect = nextEffect.nextEffect;<br>    &#125;<br>&#125; <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p><strong>commitMutationEffects</strong>  </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitMutationEffects</span><span class="hljs-params">(root: FiberRoot, renderPriorityLevel)</span> </span>&#123;<br>  <span class="hljs-comment">// 遍历effectList</span><br>  <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) &#123;<br><br>    <span class="hljs-keyword">const</span> effectTag = nextEffect.effectTag;<br><br>    <span class="hljs-comment">// 根据 ContentReset effectTag重置文字节点</span><br>    <span class="hljs-keyword">if</span> (effectTag &amp; ContentReset) &#123;<br>      commitResetTextContent(nextEffect);<br>    &#125;<br><br>    <span class="hljs-comment">// 更新ref</span><br>    <span class="hljs-keyword">if</span> (effectTag &amp; Ref) &#123;<br>      <span class="hljs-keyword">const</span> current = nextEffect.alternate;<br>      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) &#123;<br>        commitDetachRef(current);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据 effectTag 分别处理</span><br>    <span class="hljs-keyword">const</span> primaryEffectTag =<br>      effectTag &amp; (Placement | Update | Deletion | Hydrating);<br>    <span class="hljs-keyword">switch</span> (primaryEffectTag) &#123;<br>      <span class="hljs-comment">// 插入DOM</span><br>      <span class="hljs-keyword">case</span> Placement: &#123;<br>        commitPlacement(nextEffect);<br>        nextEffect.effectTag &amp;= ~Placement;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">// 插入DOM 并 更新DOM</span><br>      <span class="hljs-keyword">case</span> PlacementAndUpdate: &#123;<br>        <span class="hljs-comment">// 插入</span><br>        commitPlacement(nextEffect);<br><br>        nextEffect.effectTag &amp;= ~Placement;<br><br>        <span class="hljs-comment">// 更新</span><br>        <span class="hljs-keyword">const</span> current = nextEffect.alternate;<br>        commitWork(current, nextEffect);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">// SSR</span><br>      <span class="hljs-keyword">case</span> Hydrating: &#123;<br>        nextEffect.effectTag &amp;= ~Hydrating;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">// SSR</span><br>      <span class="hljs-keyword">case</span> HydratingAndUpdate: &#123;<br>        nextEffect.effectTag &amp;= ~Hydrating;<br><br>        <span class="hljs-keyword">const</span> current = nextEffect.alternate;<br>        commitWork(current, nextEffect);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">// 更新DOM</span><br>      <span class="hljs-keyword">case</span> Update: &#123;<br>        <span class="hljs-keyword">const</span> current = nextEffect.alternate;<br>        commitWork(current, nextEffect);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">// 删除DOM</span><br>      <span class="hljs-keyword">case</span> Deletion: &#123;<br>        commitDeletion(root, nextEffect, renderPriorityLevel);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br><br>    nextEffect = nextEffect.nextEffect;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中路由看出，commitMutationEffects会遍历effectList，对每个Fiber节点执行如下三个操作：</p><ul><li>1.根据ContentReset effectTag重置文字节点</li><li>2.更新ref</li><li>3.根据effectTag分别处理，其中effectTag包括(Placement（插入） | Update（更新） | Deletion（删除） | Hydrating（服务端渲染）)  </li><li><em>Placement effect</em>*</li></ul><p>当Fiber节点含有Placement effectTag，调用commitPlacement该Fiber节点对应的DOM节点需要插入到页面中。</p><p>commitPlacement的方法主要分为三步：</p><ul><li>1.获取父级DOM节点<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> <span class="hljs-keyword">parent</span>Fiber = getHostParentFiber(finishedWork);  // 父级DOM节点  <span class="hljs-keyword">const</span> <span class="hljs-keyword">parent</span>StateNode = <span class="hljs-keyword">parent</span>Fiber.<span class="hljs-keyword">state</span>Node;<br></code></pre></td></tr></table></figure>finishedWork为传入的Fiber节点</li><li>2.获取Fiber节点的DOM兄弟节点<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> <span class="hljs-keyword">before</span> = <span class="hljs-title">getHostSibling</span>(finishedWork);<br></code></pre></td></tr></table></figure></li><li>3.根据DOM兄弟节点是否存在决定调用parentNode.insertBefore或parentNode.appendChild执行DOM插入操作。  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-comment">// parentStateNode是否是rootFiber</span><br><span class="hljs-keyword">if</span> (isContainer) &#123;<br>insert<span class="hljs-constructor">OrAppendPlacementNodeIntoContainer(<span class="hljs-params">finishedWork</span>, <span class="hljs-params">before</span>, <span class="hljs-params">parent</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>insert<span class="hljs-constructor">OrAppendPlacementNode(<span class="hljs-params">finishedWork</span>, <span class="hljs-params">before</span>, <span class="hljs-params">parent</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>Update effect</strong></p><p>当Fiber节点含有Update effectTag，调用commitWork根据Fiber.tag分别处理。</p><p>对于FunctionComponent，也就是当fiber.tag为FunctionComponent，会调用commitHookEffectListUnmount。该方法会遍历effectList，执行所有useLayoutEffect hook的销毁函数。</p><p>对于HostComponent，fiber.tag为HostComponent（原生html标签），会调用commitUpdate。  </p><p>最终会在updateDOMProperties (opens new window)中将render阶段 completeWork (opens new window)中为Fiber节点赋值的updateQueue对应的内容渲染在页面上。</p><p><strong>Deletion effect</strong>  </p><p>当Fiber节点含有Deletion effectTag，会调用commitDeletion，把对应的DOM删除。 </p><p>commitDeletion主要执行以下操作：</p><ul><li> 递归调用Fiber节点及其子孙Fiber节点中fiber.tag为ClassComponent的componentWillUnmount (opens new window)生命周期钩子，从页面移除Fiber节点对应DOM节点</li><li>解绑ref</li><li>调度useEffect的销毁函数</li></ul><h3 id="layout-阶段"><a href="#layout-阶段" class="headerlink" title="layout 阶段"></a>layout 阶段</h3><p>layout阶段也是遍历effectList，执行commitLayoutEffects函数。  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">root.current = finishedWork;<br><br>nextEffect = firstEffect;<br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    commit<span class="hljs-constructor">LayoutEffects(<span class="hljs-params">root</span>, <span class="hljs-params">lanes</span>)</span>;<br>  &#125; catch (error) &#123;<br>    invariant(nextEffect !== null, <span class="hljs-string">&quot;Should be working on an effect.&quot;</span>);<br>    capture<span class="hljs-constructor">CommitPhaseError(<span class="hljs-params">nextEffect</span>, <span class="hljs-params">error</span>)</span>;<br>    nextEffect = nextEffect.nextEffect;<br>  &#125;<br>&#125; <span class="hljs-keyword">while</span> (nextEffect !== null);<br><br>nextEffect = null;<br></code></pre></td></tr></table></figure><p><strong>commitLayoutEffects</strong>  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> commit<span class="hljs-constructor">LayoutEffects(<span class="hljs-params">root</span>: FiberRoot, <span class="hljs-params">committedLanes</span>: Lanes)</span> &#123;<br>  <span class="hljs-keyword">while</span> (nextEffect !== null) &#123;<br>    const effectTag = nextEffect.effectTag;<br><br>    <span class="hljs-comment">// 调用生命周期钩子和hook</span><br>    <span class="hljs-keyword">if</span> (effectTag &amp; (Update <span class="hljs-pattern-match">| <span class="hljs-constructor">Callback</span>)) &#123;</span><br><span class="hljs-pattern-match">      const current = next<span class="hljs-constructor">Effect</span>.alternate;</span><br><span class="hljs-pattern-match">      commit<span class="hljs-constructor">LayoutEffectOnFiber(<span class="hljs-params">root</span>, <span class="hljs-params">current</span>, <span class="hljs-params">nextEffect</span>, <span class="hljs-params">committedLanes</span>)</span>;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 赋值<span class="hljs-built_in">ref</span></span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">if</span> (effect<span class="hljs-constructor">Tag</span> &amp; <span class="hljs-constructor">Ref</span>) &#123;</span><br><span class="hljs-pattern-match">      commit<span class="hljs-constructor">AttachRef(<span class="hljs-params">nextEffect</span>)</span>;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    next<span class="hljs-constructor">Effect</span> = next<span class="hljs-constructor">Effect</span>.next<span class="hljs-constructor">Effect</span>;</span><br><span class="hljs-pattern-match">  &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>从代码中可以看到就做了两件事：</p><ul><li><p>1.commitLayoutEffectOnFiber（调用生命周期钩子和hook相关操作）</p></li><li><p>2.commitAttachRef（赋值 ref）</p></li></ul><p><strong>commitLayoutEffectOnFiber</strong></p><p>commitLayoutEffectOnFiber方法会根据fiber.tag对不同类型的节点分别处理。</p><ul><li>对于ClassComponent，他会通过current === null?区分是mount还是update，调用componentDidMount 或componentDidUpdate。</li><li>触发状态更新的this.setState如果赋值了第二个参数回调函数，也会在此时调用。<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">this</span>.setState(&#123; xxx: <span class="hljs-number">1</span> &#125;, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;i am update~&quot;</span>);<br>  &#125;);<span class="hljs-regexp">//</span> 立马打印i am update~<br></code></pre></td></tr></table></figure></li><li>对于FunctionComponent及相关类型，他会调用useLayoutEffect hook的回调函数，调度useEffect的销毁与回调函数。<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">switch</span> (finishedWork.tag) &#123;<br>  <span class="hljs-comment">// 以下都是FunctionComponent及相关类型</span><br>  <span class="hljs-keyword">case</span> FunctionComponent:<br>  <span class="hljs-keyword">case</span> ForwardRef:<br>  <span class="hljs-keyword">case</span> SimpleMemoComponent:<br>  <span class="hljs-keyword">case</span> Block: &#123;<br>    <span class="hljs-comment">// 执行useLayoutEffect的回调函数</span><br>    commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);<br>    <span class="hljs-comment">// 调度useEffect的销毁函数与回调函数</span><br>    schedulePassiveEffects(finishedWork);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><p>mutation阶段会执行useLayoutEffect hook的销毁函数。</p><p>结合这里我们可以发现，useLayoutEffect hook从上一次更新的销毁函数调用到本次更新的回调函数调用是同步执行的。</p><p>而useEffect则需要先调度，在Layout阶段完成后再异步执行。</p><p>以上useLayoutEffect与useEffect的区别。</p><p>对于HostRoot，即rootFiber，如果赋值了第三个参数回调函数，也会在此时调用。</p><p>即ReactDom.render函数的第三个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#root&quot;</span>), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;i am mount~&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>commitAttachRef</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">function <span class="hljs-title">commitAttachRef</span>(<span class="hljs-params">finishedWork: Fiber</span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ref</span> = finishedWork.<span class="hljs-keyword">ref</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">ref</span> !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> instance = finishedWork.stateNode;<br><br>    <span class="hljs-comment">// 获取DOM实例</span><br>    <span class="hljs-keyword">let</span> instanceToUse;<br>    <span class="hljs-keyword">switch</span> (finishedWork.tag) &#123;<br>      <span class="hljs-keyword">case</span> HostComponent:<br>        instanceToUse = getPublicInstance(instance);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-literal">default</span>:<br>        instanceToUse = instance;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">ref</span> === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-comment">// 如果ref是函数形式，调用回调函数</span><br>      <span class="hljs-keyword">ref</span>(instanceToUse);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果ref是ref实例形式，赋值ref.current</span><br>      <span class="hljs-keyword">ref</span>.current = instanceToUse;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很显然，就是做了获取DOM实例，更新ref的操作。</p><p><strong>current Fiber树切换</strong></p><p>在layout之前会执行<code>root.current = finishedWork</code></p><p>componentWillUnmount会在mutation阶段执行。此时current Fiber树还指向前一次更新的Fiber树，在生命周期钩子内获取的DOM还是更新前的。</p><p>componentDidMount和componentDidUpdate会在layout阶段执行。此时current Fiber树已经指向更新后的Fiber树，在生命周期钩子内获取的DOM就是更新后的。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>React</tag>
      
      <tag>React源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端文件流处理--工作经验分享</title>
    <link href="/2021/08/01/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E6%B5%81%E5%A4%84%E7%90%86-%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <url>/2021/08/01/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E6%B5%81%E5%A4%84%E7%90%86-%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p>笔者之前遇了好几处需要处理文件流的场景，以及互相转换，这边深入的学习了一下它们的概念，区别以及互相转换，阅读本文你将了解前端常见的文件流格式，以及相互转换的思路。</p><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>一般情况之下<code>File</code>对象是<code>input</code>标签选择文件之后的<code>FileList</code>对象，也可以是也可以是来自由拖放操作生成的 <code>DataTransfer</code> 对象，或者来自 <code>HTMLCanvasElement</code> 上的 <code>mozGetAsFile() API</code>。</p><p><code>File</code>是特殊的<code>Blob</code>，可以处理<code>Blob</code>的函数必然可以处理<code>Blob</code>，比如说， <code>FileReader</code>, <code>URL.createObjectURL()</code>, <code>createImageBitmap() (en-US)</code>, 及 <code>XMLHttpRequest.send()</code> 都能处理 <code>Blob</code>和 <code>File</code>。</p><p><strong>总结:<code>File</code>是一个特殊的<code>Blob</code>对象。具体<code>API</code>参见MDN File</strong></p><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p><code>Base64</code>是一种由<code>64</code>个可打印字符组成的对二进制编码的规则<code>（binary-to-text）</code></p><h4 id="Base64解决了什么问题？"><a href="#Base64解决了什么问题？" class="headerlink" title="Base64解决了什么问题？"></a>Base64解决了什么问题？</h4><p><code>Base64</code>就是为了解决各系统以及传输协议中二进制不兼容的问题而生的。为什么<code>Base64</code>能实现兼容呢？主要还是因为各家系统只能保证<code>ASIIC</code>的基础字符，所以<code>Base64</code>就是取了其中的64个 参见<code>MDN Base64</code>。</p><p><code>Base64</code>的算法：</p><ul><li><p>1.将原始数据每三个字节作为一组，每个字节是8个bit，所以一共是 24 个 bit</p></li><li><p>2.将 24 个 bit 分为四组，每组 6 个 bit</p></li><li><p>3.在每组前面加补 00，将其补全成四组8个bit，到此步，原生数据的3个字节已经变成4个字节了，增大了将近30%</p></li><li><p>4.根据Base64码表得到扩展后每个字节的对应符号</p></li></ul><p>exp：原文为：Man的解码过程</p><p><strong>小tips：</strong></p><blockquote><p>关于Base64结尾的’=‘，而且有时候是一个有时候是两个，这是因为base64是以三个字符为一组，所以当不满三个的时候就会用’=‘补，缺一个补一个’=‘，缺两个补两个’=’。</p></blockquote><p>其实在实际开发中，我们得到的是DataURL前面一般会有<code>data:image/jpeg;base64</code>,需要注意的是,之后的才是真正的数据。</p><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p><code>Blob</code>是一个表示不可变，原始数据的文件对象，它的数据可以按文本或者二进制的格式进行读取，也可以转换成 <code>ReadableStream</code> 来用于数据操作。 具体API参见<code>MDN Blob</code></p><p>可以用<code>Blob</code>实现对大文件进行分片上传。</p><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p><code>ArrayBuffer</code> 对象用来表示通用的、固定长度的原始二进制数据缓冲区。</p><p>它是一个字节数组，通常在其他语言中称为<code>“byte array”</code>。</p><p>而<code>ArrayBuffer</code> 的内容不能直接被操作 ，而是要通过类型数组对象或 <code>DataView</code> 对象来操作，将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。</p><h2 id="2-互相转换"><a href="#2-互相转换" class="headerlink" title="2.互相转换"></a>2.互相转换</h2><p>在日常开发中我们经常遇到一些api或者组件对文件类型有要求，只这时候就需要对这些文件类型进行转化。</p><p>在这在之前先介绍一下一个<code>JS BOM API  FileReader</code></p><p><code>FileReader</code>可以读取<code>Blob</code>对象所以同时也能读取<code>File</code>对象，并且<code>FileReader</code>提供了输出<code>ArrayBuffer</code> <code>Base64</code>的接口。</p><p>下面直接贴一些转换代码：</p><p><strong>File转Base64：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileReader()</span>;<br>reader.read<span class="hljs-constructor">AsDataURL(<span class="hljs-params">file</span>[0])</span><br>console.log(reader)<br></code></pre></td></tr></table></figure><p><strong>Base64转Blob：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dataURItoBlob = <span class="hljs-function">(<span class="hljs-params">dataURI</span>) =&gt;</span> &#123;  <br>    <span class="hljs-keyword">var</span> byteString = atob(dataURI.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">1</span>]);  <br>    <span class="hljs-keyword">var</span> mimeString = dataURI.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;;&#x27;</span>)[<span class="hljs-number">0</span>];  <br>    <span class="hljs-keyword">var</span> ab = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(byteString.length);  <br>    <span class="hljs-keyword">var</span> ia = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(ab);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; byteString.length; i++) &#123;  <br>        ia[i] = byteString.charCodeAt(i);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Blob([ab], &#123;<span class="hljs-attr">type</span>: mimeString&#125;);  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Blob转ArrayBuffer：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Blob([1,2,3,4])</span><br><span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileReader()</span>;<br>reader.onload = <span class="hljs-keyword">function</span>(result) &#123;<br>    console.log(result);<br>&#125;<br>reader.read<span class="hljs-constructor">AsArrayBuffer(<span class="hljs-params">blob</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>Buffer转Blob：</strong></p><p><code>let blob = new Blob([buffer])</code></p><p><strong>Base64转File:</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> base64ConvertFile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">urlData, filename</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> urlData != <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">var</span> arr = urlData.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br><span class="hljs-keyword">var</span> <span class="hljs-keyword">type</span> = arr[<span class="hljs-number">0</span>].match(<span class="hljs-regexp">/:(.*?);/</span>)[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">var</span> fileExt = <span class="hljs-keyword">type</span>.split(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">var</span> bstr = atob(arr[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">var</span> n = bstr.length<br><span class="hljs-keyword">var</span> u8arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(n)<br><span class="hljs-keyword">while</span> (n--) &#123;<br>u8arr[n] = bstr.charCodeAt(n);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> File([u8arr], <span class="hljs-string">&#x27;filename.&#x27;</span> + fileExt, &#123;<br><span class="hljs-attr">type</span>: <span class="hljs-keyword">type</span><br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>前端常见的文件流格式有<code>Blob</code> <code>File</code> <code>Base64</code> <code>ArrayBuffer</code>，其中<code>File</code>是特殊的<code>Blob</code>对象,大部分转换都可以通过<code>JS BOM API  FileReader</code>实现。</p>]]></content>
    
    
    <categories>
      
      <category>工作经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>前端文件流</tag>
      
      <tag>文件流格式转换</tag>
      
      <tag>Blob</tag>
      
      <tag>File</tag>
      
      <tag>ArrayBuffer</tag>
      
      <tag>Base64</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖节流的react-hook版本--工作经验之解决频繁的用户操作带来的问题</title>
    <link href="/2021/06/13/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E7%9A%84react-hook%E7%89%88%E6%9C%AC-%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%A7%A3%E5%86%B3%E9%A2%91%E7%B9%81%E7%9A%84%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/13/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E7%9A%84react-hook%E7%89%88%E6%9C%AC-%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%A7%A3%E5%86%B3%E9%A2%91%E7%B9%81%E7%9A%84%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>笔者最近做项目时候，遇到qa反馈说，提交一个表单时多次点击生成了多条数据，很显然是因为没有做节流和防抖，但是对于使用react-hook函数组件来说，标准的js版本显然是不适用的（文中详细解释了各种场景下的闭包陷进），本文将写一个react-hook版本的节流和防抖。</p><span id="more"></span><h2 id="什么是节流和防抖？"><a href="#什么是节流和防抖？" class="headerlink" title="什么是节流和防抖？"></a>什么是节流和防抖？</h2><p>先来看看百度上通常能找到的概念：</p><blockquote><p>防抖意味着 N 秒内函数只会被执行一次（最后一次），如果 N 秒内再次被触发，则重新计算延迟时间。<br>节流函数的作用是规定一个单位时间，在这个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。</p></blockquote><p>什么还是不懂？</p><p>假如你经常玩游戏你可以这样理解：</p><ul><li>对于防抖来说：防抖就是技能释放需要的固定施法前摇，反复释放会重新计算前摇，前摇结束技能施放。  </li><li>对于节流来说：节流就是技能的CD（冷却时间），当处于CD状态，反复释放什么也不会发生，只有当CD转好，技能才能成功正确释放。</li></ul><p>这样是不是会更好理解。</p><h2 id="常见的js版本防抖节流"><a href="#常见的js版本防抖节流" class="headerlink" title="常见的js版本防抖节流"></a>常见的js版本防抖节流</h2><p>防抖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.call(<span class="hljs-built_in">this</span>)<br>            timer = <span class="hljs-literal">null</span><br>        &#125;, delay)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>节流：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span><br>        fn.call(<span class="hljs-built_in">this</span>)<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            timer = <span class="hljs-literal">null</span><br>        &#125;, delay);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么在react中不能正确使用？"><a href="#为什么在react中不能正确使用？" class="headerlink" title="为什么在react中不能正确使用？"></a>为什么在react中不能正确使用？</h3><p>这里先拿防抖做示例(ts版本)：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn: <span class="hljs-built_in">Function</span>, delay: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer: NodeJS.Timer | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.call(<span class="hljs-built_in">this</span>)<br>      timer = <span class="hljs-literal">null</span><br>    &#125;, delay)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const handleClick = debounce(<br>  <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;you click!&#x27;</span>)<br>  &#125;, <span class="hljs-number">1001</span><br>)<br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-regexp">//</span> 模拟点击两次<br>  (<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    handleClick()<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      handleClick()<br>    &#125;, <span class="hljs-number">1000</span>)<br>  &#125;)()<br>  const t = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1秒过去了&#x27;</span>)<br>  &#125;, <span class="hljs-number">1000</span>);<br>  <span class="hljs-keyword">return</span> () =&gt; &#123;<br>    <span class="hljs-built_in">clearInterval</span>(t)<br>  &#125;<br>&#125;, [])<br></code></pre></td></tr></table></figure><p>可以看到最终正确的在两秒后才打印：<br><img src="/2021/06/13/防抖节流的react-hook版本-工作经验之解决频繁的用户操作带来的问题/%E6%BC%94%E7%A4%BA1.png"></p><p>似乎就这样看起来一切正常，下面我换一个用例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [counter1, setCounter1] = useState(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> [counter2, setCounter2] = useState(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">const</span> handleClick = debounce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.count(<span class="hljs-string">&#x27;click1&#x27;</span>)<br>  setCounter1(counter1 + <span class="hljs-number">1</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br><br>useEffect(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> t = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    setCounter2(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>)<br>  &#125;, <span class="hljs-number">500</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(t)<br>&#125;, [])<br><br><br><span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">padding:</span> <span class="hljs-attr">30</span> &#125;&#125;&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="xml">    <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">  &gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>c1:&#123;counter1&#125;c2:&#123;counter2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>当我快速点击时这时候 控制台的打印：  </p><p><img src="/2021/06/13/防抖节流的react-hook版本-工作经验之解决频繁的用户操作带来的问题/%E6%BC%94%E7%A4%BA2.png">  </p><p>可以看到在我触发组件更新之后，我们的<code>debounce</code>失效了。<br>有人可能会说，使用<code>useCallback</code>缓存一下不就行了，是的我们使用<code>useCallback</code>确实可以解决这个问题，但是我们再一个用例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-keyword">const</span> [counter1, setCounter1] = useState(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [counter2, setCounter2] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> handleClick = useCallback(<br>    debounce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.count(<span class="hljs-string">&#x27;click1&#x27;</span>)<br>      setCounter1(counter1 + <span class="hljs-number">1</span>)<br>    &#125;, <span class="hljs-number">1000</span>),<br>    [],<br>  )<br><br>  useEffect(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> t = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCounter2(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>)<br>    &#125;, <span class="hljs-number">500</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(t)<br>  &#125;, [])<br><br><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">padding:</span> <span class="hljs-attr">30</span> &#125;&#125;&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">    &gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>c1:&#123;counter1&#125;c2:&#123;counter2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里描述一下我的操作：我进行了三次秒内连击5次  </p><p>下面是控制台还有页面:<br><img src="/2021/06/13/防抖节流的react-hook版本-工作经验之解决频繁的用户操作带来的问题/%E6%BC%94%E7%A4%BA3.png">  <img src="/2021/06/13/防抖节流的react-hook版本-工作经验之解决频繁的用户操作带来的问题/%E6%BC%94%E7%A4%BA4.png">   </p><p>虽然控制台看起来是正确的，但是由于闭包问题并不能拿到最新的<code>counter1</code>  </p><p>假如我们把改成:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lisp">const handleClick = useCallback(<br>  <span class="hljs-name">debounce</span>(<span class="hljs-name">function</span> () &#123;<br>    console.count(&#x27;click1&#x27;)<br>    setCounter1(<span class="hljs-name">counter1</span> + <span class="hljs-number">1</span>)<br>  &#125;, <span class="hljs-number">1000</span>),<br>  [counter1],<br>)<br></code></pre></td></tr></table></figure><p>这时候假如还要其他地方会使用<code>setCounter1</code>修改<code>counter1</code>时，这时候显然<code>debounce</code>就失效了（<code>counter1</code>变化时，<code>useCallback</code>的<code>callback</code>，这时候<code>timer</code>又不可靠了）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-keyword">const</span> [counter1, setCounter1] = useState(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [counter2, setCounter2] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> handleClick = useCallback(<br>    debounce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.count(<span class="hljs-string">&#x27;click1&#x27;</span>)<br>      setCounter1(counter1 + <span class="hljs-number">1</span>)<br>    &#125;, <span class="hljs-number">1000</span>),<br>    [counter1],<br>  )<br><br>  useEffect(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> t = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCounter2(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>)<br>      setCounter1(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>)<br>    &#125;, <span class="hljs-number">500</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(t)<br>  &#125;, [])<br><br><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">padding:</span> <span class="hljs-attr">30</span> &#125;&#125;&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">    &gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>c1:&#123;counter1&#125;c2:&#123;counter2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的bug不太方便演示，你可以自己测试一下，这里会发生一下闪动。</p><p>这时候又会有人说啦，你使用函数拿到上一轮的counter1更新<code>counter1</code>不就行了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> handleClick = useCallback(<br>  debounce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.count(<span class="hljs-string">&#x27;click1&#x27;</span>)<br>    setCounter1(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>)<br>  &#125;, <span class="hljs-number">1000</span>),<br>  [],<br>)<br></code></pre></td></tr></table></figure><p>是的这时候确实是能正确的<code>setCounter1</code>防抖功能又行了，但是我再换个需求呢？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lisp">const handleClick = useCallback(<br>  <span class="hljs-name">debounce</span>(<span class="hljs-name">function</span> () &#123;<br>    console.count(&#x27;click1&#x27;)<br>    setCounter1(<span class="hljs-name">x</span> =&gt; x + <span class="hljs-number">1</span>)<br>    setCounter2(<span class="hljs-name">counter1</span> + <span class="hljs-number">1</span>)<br>  &#125;, <span class="hljs-number">1000</span>),<br>  [],<br>)<br></code></pre></td></tr></table></figure><p>这时候就死局了，如果你写依赖<code>debounce</code>又失效了。  </p><p>如果你对<code>hook</code>比较了解，这时候肯定有一个呼之欲出的<code>hook</code>,没错就是<code>useRef</code>!</p><p><code>useRef</code>生成的<code>ref</code>对象可以保证在所以渲染周期内都不会改变，这样我们就可以把timer绑定在<code>ref</code>上，打造一个可靠的<code>timer</code></p><h2 id="使用useRef打造可靠的防抖节流"><a href="#使用useRef打造可靠的防抖节流" class="headerlink" title="使用useRef打造可靠的防抖节流"></a>使用useRef打造可靠的防抖节流</h2><p>这里直接上代码！</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useDebounceFn</span>(<span class="hljs-params">func: <span class="hljs-built_in">Function</span>, delay: <span class="hljs-built_in">number</span>, immediate: <span class="hljs-built_in">boolean</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> &#123; current &#125; = useRef&lt;&#123; <span class="hljs-attr">timer</span>: NodeJS.Timeout | <span class="hljs-literal">null</span> &#125;&gt;(&#123; <span class="hljs-attr">timer</span>: <span class="hljs-literal">null</span> &#125;),<br>    <span class="hljs-attr">result</span>: unknown;<br>  <span class="hljs-keyword">const</span> resDebounced = <span class="hljs-function">(<span class="hljs-params">...args: unknown[]</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 一直触发一直清除上一个打开的延时器</span><br>    <span class="hljs-keyword">if</span> (current.timer) <span class="hljs-built_in">clearTimeout</span>(current.timer);<br><br>    <span class="hljs-keyword">if</span> (immediate) &#123;<br>      <span class="hljs-comment">// 第一次触发，timeout===undefined恰好可以利用timeout的值</span><br>      <span class="hljs-keyword">const</span> callNow = !current.timer;<br>      current.timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        current.timer = <span class="hljs-literal">null</span>;<br>      &#125;, delay);<br>      <span class="hljs-keyword">if</span> (callNow) result = func.apply(<span class="hljs-literal">null</span>, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 停止触发，只有最后一个延时器被保留</span><br>      current.timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        current.timer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// func绑定this和事件对象event，还差一个函数返回值</span><br>        result = func.apply(<span class="hljs-literal">null</span>, args);<br>      &#125;, delay);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>  resDebounced.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (current.timer) <span class="hljs-built_in">clearTimeout</span>(current.timer);<br>    current.timer = <span class="hljs-literal">null</span>;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> resDebounced;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useDebounceFn;<br><br></code></pre></td></tr></table></figure><p>节流就留给聪明的你写吧！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于<code>react-hook</code>的更新机制，每次更新都会反复重新执行，因此每次渲染都是一个新的闭包，在这样的场景下,常规的js版本防抖节流会变得不可靠，甚至失效。因此我们需要依赖<code>react</code>的可靠不变<code>useRef</code>挂载一个可靠的<code>timer</code>，实现防抖和节流。</p>]]></content>
    
    
    <categories>
      
      <category>工作经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>节流防抖</tag>
      
      <tag>useRef</tag>
      
      <tag>闭包陷进</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后端同事改了登录接口导致我五分钟刷新一次。。。--工作经验之用户登录设计</title>
    <link href="/2021/06/08/%E5%90%8E%E7%AB%AF%E5%90%8C%E4%BA%8B%E6%94%B9%E4%BA%86%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E5%AF%BC%E8%87%B4%E6%88%91%E4%BA%94%E5%88%86%E9%92%9F%E5%88%B7%E6%96%B0%E4%B8%80%E6%AC%A1%E3%80%82%E3%80%82%E3%80%82-C%E7%AB%AF%E7%99%BB%E5%BD%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/06/08/%E5%90%8E%E7%AB%AF%E5%90%8C%E4%BA%8B%E6%94%B9%E4%BA%86%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E5%AF%BC%E8%87%B4%E6%88%91%E4%BA%94%E5%88%86%E9%92%9F%E5%88%B7%E6%96%B0%E4%B8%80%E6%AC%A1%E3%80%82%E3%80%82%E3%80%82-C%E7%AB%AF%E7%99%BB%E5%BD%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>最近开始做新项目，是一个toC项目，之前的登录接口是一个实习生写的，偶然间另一位同事看了看项目代码之后跟我说为了提高安全性，修改了登录接口。。。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>博主在做的一个项目之前的登录接口是实习生写的，登录设计就是简单的提交用户名密码获取token，然后token的过期时间巨长是30天，于是乎另一位工作年限长一点的同事修改了代码，变成了登录获取两个token：</p><ul><li>1.<code>accessToken</code>: 真正用来获取数据的权限</li><li>2.<code>refreshToken</code>: 用来获取<code>accessToken</code></li></ul><h2 id="为什么需要双token"><a href="#为什么需要双token" class="headerlink" title="为什么需要双token?"></a>为什么需要双<code>token</code>?</h2><p>总所周知，<code>token</code>是为了防止用户信息传来传去导致被劫持，但是假如<code>token</code>没有过期时间或者过期很长，那么显然<code>token</code>被劫持还是不安全的，<code>token</code>就失去了意义。</p><p>所以这时候大家肯定都想：那么把<code>token</code>过期时间设置的短一点就行啦？  </p><p>是的，一般来讲<code>accessToken</code>的过期时间应该要短一点，但是这时候对于用户来讲就麻烦了。</p><p>因为<code>token</code>过期就意味着要重新登录，想象下你正浏览的好好的，突然让你掉线了并且要求你重新登录，心里肯定是想骂人的。</p><p><strong>什么时候需要用户重新登录？</strong>  </p><p>主要有三种情况：</p><ul><li>1.用户长时间无操作，也可以定义未不活跃用户，就会被自动踢下，自动重定向到登录页面，超时时间可以自定义设置；</li><li>2.token失效，通常是双token都失效后，会要求重新登录获取新的双token；</li><li>3.当检测到有风险的时候，可以要求重新登录，获取token；</li></ul><p>因此这时候就可以使用双<code>token</code>的设计，当两个<code>token</code>都过期了再要求用户重新登录，对于<code>refreshToken</code>，它只用来获取<code>accessToken</code>,不会频繁被用于请求，对于<code>accessToken</code>，它过期时间非常短，即使被拦截了解密也需要时间，而<code>token</code>本身也很快过期，因此这样的设计更加安全。</p><p>那么就这样就皆大欢喜了吗？显然不是作为前端，我们还需要实现让用户对于使用<code>refreshToken</code>获取<code>accessToken</code>的操作是无感的。</p><h2 id="refreshToken获取token无感刷新"><a href="#refreshToken获取token无感刷新" class="headerlink" title="refreshToken获取token无感刷新?"></a><code>refreshToken</code>获取<code>token</code>无感刷新?</h2><p>总的来说一般有三种方法：</p><ul><li>1.通过后端返回过期时间，前端根据当前时间与这个过期时间做判断,去调用刷新token接口  <blockquote><p>缺点：需要后端额外提供一个Token过期时间的字段；使用了本地时间判断，若本地时间被篡改，特别是本地时间比服务器时间慢时，拦截会失败。</p></blockquote></li><li>2.定时任务，定时使用<code>refreshToken</code>获取<code>accessToken</code><blockquote><p>浪费资源,消耗性能,不建议采用。</p></blockquote></li><li>3.做响应拦截器中拦截，后端判断<code>token</code> 返回过期后，调用刷新token接口<blockquote><p>比较好的方案，也是我在项目中使用的方案，并且axios有做响应拦截的api</p></blockquote></li></ul><p>这里贴一个简单的实现demo:  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> axios from <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br>axios.interceptors.response.use(res =&gt; &#123;<br>        <span class="hljs-comment">// token异常</span><br>        <span class="hljs-keyword">if</span> (res.<span class="hljs-keyword">data</span>.code === <span class="hljs-number">409</span>) &#123;<br>            deleteToken();<br>            router.push(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>            <span class="hljs-keyword">return</span> Promise.reject();<br>            <span class="hljs-comment">// 更新Token</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-keyword">data</span>.code === <span class="hljs-number">410</span>) &#123;<br>            <span class="hljs-keyword">const</span> &#123;token&#125; = res.<span class="hljs-keyword">data</span><br>            setToken(token);<span class="hljs-comment">// 重置token</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res &amp;&amp; res.<span class="hljs-keyword">data</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了用户安全因此要使用<code>token</code>设计，为了解决用户频繁登录，采用双<code>token</code>设计，同时前端也需要做一定处理。</p>]]></content>
    
    
    <categories>
      
      <category>工作经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>登录设计，双token设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为了学习Promise我手写了一个PromiseA+并实现了所有静态方法......--再学JavaScript系列</title>
    <link href="/2021/03/10/%E5%86%8D%E5%AD%A6JavaScript%E7%B3%BB%E5%88%97-%E6%89%8B%E5%86%99PromiseA/"/>
    <url>/2021/03/10/%E5%86%8D%E5%AD%A6JavaScript%E7%B3%BB%E5%88%97-%E6%89%8B%E5%86%99PromiseA/</url>
    
    <content type="html"><![CDATA[<p><code>Promise</code>作为<code>JavaScript</code>异步编程最重要的知识之一，对其深入探讨非常有必要，即使你在工作中肯定不会自己去手写实现<code>Promise</code>（<del>是滴，为了装逼</del>），阅读本文你将了解<code>Promise</code>的实现细节，以及一些静态方法（包括<code>all</code> <code>race</code> <code>any</code> <code>allSettled</code>）的实现。<br>本文采用<code>ES6 class</code>语法实现，并且在阅读本文之前请确保对异步、以及<code>JavaScript</code>的事件循环机制（<code>event loop</code>）有一定了解。</p><span id="more"></span><h2 id="什么是Promise-A"><a href="#什么是Promise-A" class="headerlink" title="什么是Promise A+"></a>什么是Promise A+</h2><p><code>Promise A+</code>是一种规范，具体可见 <a href="https://promisesaplus.com/">Promise A+ 规范</a></p><h2 id="手写具体实现"><a href="#手写具体实现" class="headerlink" title="手写具体实现"></a>手写具体实现</h2><h3 id="1-Promise状态"><a href="#1-Promise状态" class="headerlink" title="1.Promise状态"></a>1.Promise状态</h3><p>据A+规范固定，一个<code>Promise</code>只能可能以下三种状态之一:<br><code>pending</code>：<code>Promise</code>的初始状态，表示等待，可以改变至<code>fulfilled</code>或者<code>rejected</code><br><code>fulfilled</code>：<code>Promise</code>的完成状态，表示成功，状态不可再改变，拥有一个<code>value</code>值，并且会执行成功的回调函数（<code>then</code>方法的第一个参数）<br><code>rejected</code>： <code>Promise</code>的拒绝状态，表示失败，状态同样不可再改变，拥有一个<code>reason</code>值，并且会执行失败的回调函数（<code>then</code>方法的第二个参数，以及<code>catch</code>方法的参数）<br>状态变化如下图：<br><img src="/2021/03/10/再学JavaScript系列-手写PromiseA/promsie%E7%8A%B6%E6%80%81%E6%9C%BA.png" title="promise状态机"><br>所以我们先定义好这三个状态的私有变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> states = &#123;<br>    pending: <span class="hljs-built_in">Symbol</span>(),<br>    fulfilled: <span class="hljs-built_in">Symbol</span>(),<br>    rejected: <span class="hljs-built_in">Symbol</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里用symbol有个好处，就是能消除魔术字符串，当然也可以用这种:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;pending&#x27;</span><br></code></pre></td></tr></table></figure><p>我在实际项目中习惯使用前者</p><h3 id="2-模拟异步"><a href="#2-模拟异步" class="headerlink" title="2.模拟异步"></a>2.模拟异步</h3><p>总所周知在<code>JavaScript</code>api里<code>Promise</code>是异步微任务，注：promiseA+没有规定怎么实现，这里我们可以模拟一下（其实还可以用<code>node</code><br>中的<code>queueMicrotask</code>）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">const</span> asyncFn = (() =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (process &amp;&amp; process.nextTick) <span class="hljs-keyword">return</span> process.nextTick<br>    <span class="hljs-keyword">return</span> setTimeout<br>&#125;)()<br><br></code></pre></td></tr></table></figure><h3 id="3-myPromise类编写"><a href="#3-myPromise类编写" class="headerlink" title="3.myPromise类编写"></a>3.myPromise类编写</h3><p>这里我们用ES6的Class语法来实现，当然也可以直接原型链上写  </p><h3 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4.构造函数"></a>4.构造函数</h3><p><code>Promise</code>构造函数接受一个参数，并具有初始状态<code>pending</code>，并且当这个函数抛出异常时返回一个失败的<code>Promise</code>,除此之外，这个函数有两个参数：第一个是将状态改变为<code>fulfilled</code>的<code>resolve</code>，第二个是将状态改变为<code>rejected</code>的<code>reject</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myPromise</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(initCallback) &#123;<br><br>        <span class="hljs-comment">// 初始化promise</span><br>        <span class="hljs-keyword">this</span>.state = states.pending<br>        <span class="hljs-keyword">this</span>.value = undefined<br>        <span class="hljs-keyword">this</span>.reason = undefined<br><br>        <span class="hljs-comment">// 用两个数组去存储成功和失败的回调，以便成功失败后调用</span><br>        <span class="hljs-keyword">this</span>.fulfilledCbStack = []<br>        <span class="hljs-keyword">this</span>.rejectedCbStack = []<br><br>        <span class="hljs-comment">// initCallback的resolve参数</span><br>        <span class="hljs-keyword">const</span> resolve = (value) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === states.pending) &#123;<br>                <span class="hljs-keyword">this</span>.state = states.fulfilled<br>                <span class="hljs-keyword">this</span>.value = value<br>                <span class="hljs-comment">// 这里forEach的参数是个箭头函数因此我们可以直接.call绑定this，否则需要将this保存并在forEach的费箭头函数中绑定上callback并执行，reject同理</span><br>                <span class="hljs-keyword">this</span>.fulfilledCbStack.forEach((cb) =&gt; cb.call(<span class="hljs-keyword">this</span>))<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// initCallback的reject参数</span><br>        <span class="hljs-keyword">const</span> reject = (reason) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === states.pending) &#123;<br>                <span class="hljs-keyword">this</span>.state = states.rejected<br>                <span class="hljs-keyword">this</span>.reason = reason<br>                <span class="hljs-keyword">this</span>.rejectedCbStack.forEach((cb) =&gt; cb.call(<span class="hljs-keyword">this</span>))<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 执行构造回调函数</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            initCallback(resolve, reject)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            reject(e)<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里说一下细节<br>首先是为什么要初始化两个数组去存储回调函数，其实是为了当一个<code>Promise</code>传入了多个then回调函数能够确保全部执行。比如我们看看以下这种情况：  </p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(res)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>        res(<span class="hljs-number">0</span>)<br>    &#125;,<span class="hljs-number">3000</span>)<br>&#125;)<br>p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(v)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cb1&#x27;</span>,v+<span class="hljs-number">1</span>)<br>&#125;)<br>p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(v)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cb2&#x27;</span>,v+<span class="hljs-number">2</span>)<br>&#125;)<br>p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(v)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cb3&#x27;</span>,v+<span class="hljs-number">3</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ <span class="hljs-keyword">node</span> <span class="hljs-title">./index</span>.js<br>cb1 <span class="hljs-number">1</span><br>cb2 <span class="hljs-number">2</span><br>cb3 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>在<code>resolve</code> <code>reject</code> 方法中改变<code>promise</code>的状态并且执行缓存的<code>callback</code>。 </p><p>执行构造函数的函数参数时需要去捕获异常，并且在捕获到异常时执行 <code>reject（）</code>函数。</p><p>写到这里其实大家可以打印下<code>Promise</code>实例中的状态，以及是否成功缓存<code>callback</code>，以及在生成<code>Promise</code>实例时抛出异常是否捕获以及返回正确的<code>Promise</code>对象。</p><h3 id="5-then方法"><a href="#5-then方法" class="headerlink" title="5.then方法"></a>5.then方法</h3><p><code>then</code>方法或者说官方A+文档所说的<code>thenable</code>方法，这是<code>Promise</code>非常关键以及重要的方法，是核心逻辑之一.  </p><p><code>then</code>方法有两个可选参数，分别是成功的回调和失败的回调，<code>then</code>方法会返回一个<code>Promise</code>。</p><p>A+文档描述如下：  </p><ul><li><code>Promise</code>必须提供一个then方法来访问当前或最终的值或原因,<code>Promise</code>的then方法接受俩个参数：<code>Promise.then(onFulfilled, onRejected)</code>。</li><li>onFulfilled和onRejected都是可选的参数。<ul><li>如果onFulfilled是一个函数,必须在<code>Promise</code>被解决后调用，<code>Promise</code>的值作为它的第一个参数,一定不能在<code>Promise</code>被解决前调用,一定不能被调用多次。</li><li>如果<code>onRejected</code>是一个函数,必须在<code>Promise</code>被拒绝之后调用，用<code>Promise</code>的原因作为它的第一个参数,一定不能在<code>Promise</code>被拒绝之前调用,一定不能被调用多次。</li></ul></li><li>在执行上下文栈中只包含平台代码之前，<code>onFulfilled</code>或<code>onRejected</code>一定不能被调用。</li><li><code>onFulfilled</code>和<code>onRejected</code>一定被作为函数调用(没有<code>this</code>值)</li><li>同一个<code>Promise</code>上的<code>then</code>可能被调用多次。<ul><li>如果<code>Promise</code>被解决，所有相应的<code>onFulfilled</code>回调必须按照他们原始调用<code>then</code>的顺序执行</li><li>如果<code>Promise</code>被拒绝，所有相应的<code>onRejected</code>回调必须按照他们原始调用<code>then</code>的顺序执行</li></ul></li><li><code>then</code>必须返回一个<code>Promise</code></li></ul><p>这里笔者其实写了两个版本，但是后来遇到了一些问题之后(漏掉了A+文档的2.3部分)重看了A+以及一些网上的正确实现写了第二个版本，我们先来看看第一个版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resCallback, rejCallback</span>)</span> &#123;<br><br>    <span class="hljs-comment">// 因为then方法参数没有规定类型，这里需要做简单处理</span><br>    resCallback = resCallback <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> ? resCallback : <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v<br>    rejCallback = rejCallback <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> ? rejCallback : <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">throw</span> e<br>    &#125;<br><br>    <span class="hljs-comment">// 根据A+规定 then方法一定返回一个新的Promise 这里我们二话不说先返回一个新的Promise</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br><br>        <span class="hljs-comment">// 成功的handleCb逻辑</span><br>        <span class="hljs-keyword">const</span> handleFulfilledCb = <span class="hljs-function">() =&gt;</span> &#123;<br>            asyncFn(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">const</span> newValue = resCallback(<span class="hljs-built_in">this</span>.value)<br>                    res(newValue)<br>                &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                    rej(e)<br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-comment">// 失败的handleCb逻辑</span><br>        <span class="hljs-keyword">const</span> handleRejectedCb = <span class="hljs-function">() =&gt;</span> &#123;<br>            asyncFn(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">const</span> newValue = rejCallback(<span class="hljs-built_in">this</span>.reason)<br>                    res(newValue)<br>                &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                    rej(e)<br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-comment">// 根据当前promise状态执行不同逻辑</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.pending) &#123;<br>            <span class="hljs-comment">// 如果是pending把callback缓存</span><br>            <span class="hljs-built_in">this</span>.fulfilledCbStack.push(handleFulfilledCb)<br>            <span class="hljs-built_in">this</span>.rejectedCbStack.push(handleRejectedCb)<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.fulfilled) &#123;<br>            <span class="hljs-comment">// 如果是fulfilled执行成功的方法</span><br>            <span class="hljs-keyword">return</span> handleFulfilledCb()<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.rejected) &#123;<br>            <span class="hljs-comment">// 如果是rejected执行失败的方法</span><br>            <span class="hljs-keyword">return</span> handleRejectedCb()<br>        &#125;<br><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码比较长，主要的细节都在注释里说明了，我们来看看还存在上面问题。  </p><p>看一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>    res(<span class="hljs-number">0</span>)<br>&#125;);<br><span class="hljs-keyword">const</span> p2 = p1.then(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> p2<br>&#125;)<br></code></pre></td></tr></table></figure><p>运行发现：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># ninthworld @ 192 in ~/my_space/demo [23:55:42] </span><br>$ <span class="hljs-keyword">node</span> <span class="hljs-title">./index</span>.js<br><br><span class="hljs-comment"># ninthworld @ 192 in ~/my_space/demo [23:56:12] </span><br>$ <br></code></pre></td></tr></table></figure><p>什么都没发生，是的因为这里发生了循环引用！这个promise永远都不可能完成，并且我们把上面的代码换成<code>Promise</code>也就是<code>JavaScript</code>本身的<code>Promise</code>api，执行结果如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ node ./index.js<br>(node:<span class="hljs-number">38662</span>) UnhandledPromiseRejectionWarning: TypeError: Chaining cycle detected <span class="hljs-keyword">for</span> promise <span class="hljs-comment">#&lt;Promise&gt;</span><br>(node:<span class="hljs-number">38662</span>) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="hljs-keyword">function</span> without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https:<span class="hljs-regexp">//</span>nodejs.org<span class="hljs-regexp">/api/</span>cli.html<span class="hljs-comment">#cli_unhandled_rejections_mode). (rejection id: 1)</span><br>(node:<span class="hljs-number">38662</span>) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero <span class="hljs-keyword">exit</span> code.<br></code></pre></td></tr></table></figure><p>是的，报错了。于是我去翻看A+文档其中有<code>2.2.7</code>有以下规定：<br><code>onFulfilled</code> 或 <code>onRejected</code> 返回一个值 x, 执行 <code>Promise Resolution Procedure    [Resolve]</code>。  </p><p>关于这个<code>Promise Resolution Procedure</code> A+文档中有很长一段解释，总结一下就是对于then的各种返回值做处理：  </p><ol><li>如果 promise and x 是同一个引用<ul><li>promise.reject(TypeError)</li></ul></li><li>如果 x 是一个 promise<ul><li>x 是 pending 的时候  <ul><li>promise 等待 x resolve 或者 reject。</li></ul></li><li>x 是 fulfilled 的时候  <ul><li>promise.resolve(x.value)  </li></ul></li><li>x 是 rejected 的时候  <ul><li>promise._reject(x.reason)    </li></ul></li></ul></li><li>x 是一个 object 或者一个 function  <ul><li>如果 x.then 存在，then = x.then</li><li>如果在得到 x.then 的值的过程中报错，promise reject 这个错误</li></ul></li><li>x 既不是 Object 和 function，也不是 Promise<ul><li>promise._resolve(x)</li></ul></li></ol><p>那么了解了以上的规则之后我们来这个<code>Promise Resolution Procedure</code>吧 </p><h3 id="6-编写Promise-Resolution-Procedure"><a href="#6-编写Promise-Resolution-Procedure" class="headerlink" title="6.编写Promise Resolution Procedure"></a>6.编写Promise Resolution Procedure</h3><p>这里说明下，<code>Promise Resolution Procedure</code>是一个私有方法，但是遗憾的是<code>JavaScript</code>这门语言并不支持<code>private</code>关键字，因此我们可以把这个方法声明在类外，做一个伪私有而不让实例，以及类上能主动调用。下面是具体代码：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> resolvePromise = <span class="hljs-function">(<span class="hljs-params">p, x, res, rej</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 处理循环引用</span><br>  <span class="hljs-keyword">if</span> (p === x) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Chaining cycle detected for promise&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 如果是myPromise直接调用then方法</span><br>  <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> myPromise) <span class="hljs-keyword">return</span> x.then(res, rej)<br><br>  <span class="hljs-comment">// 处理thenable引用数据，即含有then的数据</span><br>  <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>    <span class="hljs-comment">// then 用来访问x上的then called顾名思义，标记是否已经调用过</span><br>    <span class="hljs-keyword">let</span> then, called<br>    <span class="hljs-keyword">try</span> &#123;<br>      then = x.then<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-comment">// 处理访问then出错</span><br>      <span class="hljs-keyword">return</span> rej(e)<br>    &#125;<br>    <span class="hljs-comment">// 如果then是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        then.call(x, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) </span>&#123;<br>          <span class="hljs-keyword">if</span> (!called) &#123;<br>            called = <span class="hljs-literal">true</span><br>            resolvePromise(p, y, res, rej)<br>          &#125;<br>        &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">r</span>) </span>&#123;<br>          <span class="hljs-keyword">if</span> (!called) &#123;<br>            called = <span class="hljs-literal">true</span><br>            rej(r)<br>          &#125;<br>        &#125;)<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-keyword">if</span> (!called) &#123;<br>          rej(e)<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res(x)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res(x)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并把<code>then</code>方法部分代码重写：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resCallback, rejCallback</span>)</span> &#123;<br>  <br>  <span class="hljs-comment">// 因为then方法参数没有规定类型，这里需要做简单处理</span><br>  resCallback = resCallback <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> ? resCallback : <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v<br>  rejCallback = rejCallback <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> ? rejCallback : <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> e<br>  &#125;<br><br>  <span class="hljs-comment">// 根据A+规定 then方法一定返回一个新的Promise 这里我们二话不说先返回一个新的Promise</span><br>  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br><br>    <span class="hljs-comment">// 成功的handleCb逻辑</span><br>    <span class="hljs-keyword">const</span> handleFulfilledCb = <span class="hljs-function">() =&gt;</span> &#123;<br>      asyncFn(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> x = resCallback(<span class="hljs-built_in">this</span>.value)<br>          resolvePromise(p, x, res, rej)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          rej(e)<br>        &#125;<br>      &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 失败的handleCb逻辑</span><br>    <span class="hljs-keyword">const</span> handleRejectedCb = <span class="hljs-function">() =&gt;</span> &#123;<br>      asyncFn(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> x = rejCallback(<span class="hljs-built_in">this</span>.reason)<br>          resolvePromise(p, x, res, rej)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          rej(e)<br>        &#125;<br>      &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 根据当前promise状态执行不同逻辑</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.pending) &#123;<br>      <span class="hljs-comment">// 如果是pending把callback缓存</span><br>      <span class="hljs-built_in">this</span>.fulfilledCbStack.push(handleFulfilledCb)<br>      <span class="hljs-built_in">this</span>.rejectedCbStack.push(handleRejectedCb)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.fulfilled) &#123;<br>      <span class="hljs-comment">// 如果是fulfilled执行成功的方法</span><br>      <span class="hljs-keyword">return</span> handleFulfilledCb()<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.rejected) &#123;<br>      <span class="hljs-comment">// 如果是rejected执行失败的方法</span><br>      <span class="hljs-keyword">return</span> handleRejectedCb()<br>    &#125;<br><br>  &#125;)<br>  <span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><p>构函数处的<code>resolve</code>方法也用<code>Promise Resolution Procedure</code>去处理:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> initCallback的resolve参数<br>const resolve = <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>  resolvePromise(<span class="hljs-built_in">this</span>, value, <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.pending) &#123;<br>      <span class="hljs-built_in">this</span>.state = states.fulfilled<br>      <span class="hljs-built_in">this</span>.value = value<br>      <span class="hljs-regexp">//</span> 这里forEach的参数是个箭头函数因此我们可以直接.call绑定<span class="hljs-built_in">this</span>，否则需要将<span class="hljs-built_in">this</span>保存并在forEach的费箭头函数中绑定上callback并执行，reject同理<br>      <span class="hljs-built_in">this</span>.fulfilledCbStack.forEach(<span class="hljs-function"><span class="hljs-params">(cb)</span> =&gt;</span> cb.call(<span class="hljs-built_in">this</span>))<br>    &#125;<br>  &#125;, reject)<br>&#125;<br></code></pre></td></tr></table></figure><p>并且加上catch方法的实现(其实就是<code>then</code>方法的语法糖)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">catch</span> (cb_catch) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, cb_catch)<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，手写<code>Promise A+</code>部分的全部工作就完成啦！</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>先安装<code>promises-aplus-tests</code>这个测试库  </p><p>加入测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myPromise.deferred = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> result = &#123;&#125;;<br>  result.promise = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    result.resolve = resolve;<br>    result.reject = reject;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = myPromise;<br></code></pre></td></tr></table></figure><p>测试结果:<br><img src="/2021/03/10/再学JavaScript系列-手写PromiseA/promise%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" title="A+测试结果"><br>大功告成！872个测试用例都完美通过，成就感满满！</p><h2 id="Promise的静态方法"><a href="#Promise的静态方法" class="headerlink" title="Promise的静态方法"></a>Promise的静态方法</h2><p>经过上面的锻炼，我们对<code>Promise</code>已经有了比较深入的了解，接下来可以对<code>Promise</code>进行一些拓展实现,其实几乎所有的API都是基于<code>then</code>方法去做拓展。</p><h3 id="Promise-resolve-和-Promise-reject"><a href="#Promise-resolve-和-Promise-reject" class="headerlink" title="Promise.resolve 和 Promise.reject"></a>Promise.resolve 和 Promise.reject</h3><p>这两个API其实都比较简单,<code>Promise.resolve</code>返回一个成功的<code>Promise</code>,<code>Promise.reject</code>返回一个失败的<code>Promise</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> myPromise) <span class="hljs-keyword">return</span> value<br>  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> &amp;&amp; value.then <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>      value.then(res, rej)<br>    &#125;)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    res(value)<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">value</span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">_, rej</span>) =&gt;</span> &#123;<br>    rej(value)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>没太多可说的。</p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p><code>Promise.all</code>是非常常用的API，它接受一个数组参数，并返回一个<code>Promise</code>,当数组中每一个任务都<code>fulfilled</code>时,这个<code>Promise</code>状态为<code>fulfilled</code>,并且按顺序把每一个<code>Promise</code>的<code>value</code>存在一个数组上并返回,一旦其中一个<code>Promise</code>被<code>reject</code>，则这个返回的<code>Promise</code>也被<code>reject</code>。<br>ps： <code>Promise.all</code>是并行的，并且被<code>reject</code>之后，不会打断其他<code>Promise</code>的执行，其他的<code>Promise</code>照常执行,但是获取不到<code>value</code>。<br>下面是代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">all</span>(<span class="hljs-params">promiseList</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> resCount = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> resList = []<br>      promiseList.forEach(<span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 处理非Promise参数</span><br>        <span class="hljs-keyword">const</span> p = item <span class="hljs-keyword">instanceof</span> myPromise ? item : <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          res(item)<br>        &#125;)<br>        p.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          resList[i] = value<br>          resCount++<br>          <span class="hljs-comment">// 判断是否全部执行成功</span><br>          <span class="hljs-keyword">if</span> (resCount === promiseList.length) res(resList)<br>        &#125;)<br>        p.catch(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          rej(value)<br>        &#125;)<br>      &#125;)<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">static race(promiseList) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">(res, rej)</span> =&gt;</span> &#123;<br>    promiseList.forEach(<span class="hljs-function"><span class="hljs-params">(item)</span> =&gt;</span> &#123;<br>      const p = item <span class="hljs-keyword">instanceof</span> myPromise ? item : <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>        res(item)<br>      &#125;)<br>      p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>        res(value)<br>      &#125;)<br>      p.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>        rej(value)<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">static allSettled(promiseList) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>    let resList = []<br>    promiseList.forEach(<span class="hljs-function"><span class="hljs-params">(item, i)</span> =&gt;</span> &#123;<br>      const p = item <span class="hljs-keyword">instanceof</span> myPromise ? item : <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>        res(item)<br>      &#125;)<br>      p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>        resList[i] = &#123;<br>          status: <span class="hljs-string">&#x27;fulfilled&#x27;</span>,<br>          value<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resList.flat().length === promiseList.length) res(resList)<br>      &#125;)<br>      p.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;<br>        resList[i] = &#123;<br>          status: <span class="hljs-string">&#x27;rejected&#x27;</span>,<br>          reason<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resList.flat().length === promiseList.length) res(resList)<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">static any(promiseList) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">(res, rej)</span> =&gt;</span> &#123;<br>    let resList = <span class="hljs-keyword">new</span> AggregateError()<br>    promiseList.forEach(<span class="hljs-function"><span class="hljs-params">(item, i)</span> =&gt;</span> &#123;<br>      const p = item <span class="hljs-keyword">instanceof</span> myPromise ? item : <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>        res(item)<br>      &#125;)<br>      p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>        res(value)<br>      &#125;)<br>      p.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>        resList[i] = value<br>        <span class="hljs-keyword">if</span> (resList.flat().length === promiseList.length) rej(resList)<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Promise</code>作为<code>JavaScript</code>最常用异步解决方案之一，其实原理并不复杂，但是也有非常多的细节，不过这里仍然要提一下，不同浏览器不同的引擎对于Promise的实现可能不同，会有不同的优化。通过手写一个<code>Promise</code>，以及各种静态方法，可以非常好的提升我们对于<code>Promise</code>的理解，以及一些静态方法的理解和使用。<br>PS: 由于没有跑对<code>Promise</code>静态方法的测试包，本文只进行了简单的测试，可能会存在对于一些特殊情况运行出错，欢迎联系我交流指正！</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 手写promise</span><br><span class="hljs-keyword">const</span> states = &#123;<br>  <span class="hljs-attr">pending</span>: <span class="hljs-built_in">Symbol</span>(),<br>  <span class="hljs-attr">fulfilled</span>: <span class="hljs-built_in">Symbol</span>(),<br>  <span class="hljs-attr">rejected</span>: <span class="hljs-built_in">Symbol</span>()<br>&#125;<br><span class="hljs-keyword">const</span> asyncFn = (<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (process &amp;&amp; process.nextTick) <span class="hljs-keyword">return</span> process.nextTick<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">setTimeout</span><br>&#125;)()<br><br><span class="hljs-keyword">const</span> resolvePromise = <span class="hljs-function">(<span class="hljs-params">p, x, res, rej</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 处理循环引用</span><br>  <span class="hljs-keyword">if</span> (p === x) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Chaining cycle detected for promise&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 如果是myPromise直接调用then方法</span><br>  <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> myPromise) <span class="hljs-keyword">return</span> x.then(res, rej)<br><br>  <span class="hljs-comment">// 处理thenable引用数据，即含有then的数据</span><br>  <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>    <span class="hljs-comment">// then 用来访问x上的then called顾名思义，标记是否已经调用过</span><br>    <span class="hljs-keyword">let</span> then, called<br>    <span class="hljs-keyword">try</span> &#123;<br>      then = x.then<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-comment">// 处理访问then出错</span><br>      <span class="hljs-keyword">return</span> rej(e)<br>    &#125;<br>    <span class="hljs-comment">// 如果then是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        then.call(x, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) </span>&#123;<br>          <span class="hljs-keyword">if</span> (!called) &#123;<br>            called = <span class="hljs-literal">true</span><br>            resolvePromise(p, y, res, rej)<br>          &#125;<br>        &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">r</span>) </span>&#123;<br>          <span class="hljs-keyword">if</span> (!called) &#123;<br>            called = <span class="hljs-literal">true</span><br>            rej(r)<br>          &#125;<br>        &#125;)<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-keyword">if</span> (!called) &#123;<br>          rej(e)<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res(x)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res(x)<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myPromise</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">initCallback</span>)</span> &#123;<br><br>    <span class="hljs-comment">// 初始化promise</span><br>    <span class="hljs-built_in">this</span>.state = states.pending<br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span><br>    <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">undefined</span><br><br>    <span class="hljs-comment">// 用两个数组去存储成功和失败的回调，以便成功失败后调用</span><br>    <span class="hljs-built_in">this</span>.fulfilledCbStack = []<br>    <span class="hljs-built_in">this</span>.rejectedCbStack = []<br><br>    <span class="hljs-comment">// initCallback的resolve参数</span><br>    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      resolvePromise(<span class="hljs-built_in">this</span>, value, <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.pending) &#123;<br>          <span class="hljs-built_in">this</span>.state = states.fulfilled<br>          <span class="hljs-built_in">this</span>.value = value<br>          <span class="hljs-comment">// 这里forEach的参数是个箭头函数因此我们可以直接.call绑定this，否则需要将this保存并在forEach的费箭头函数中绑定上callback并执行，reject同理</span><br>          <span class="hljs-built_in">this</span>.fulfilledCbStack.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb.call(<span class="hljs-built_in">this</span>))<br>        &#125;<br>      &#125;, reject)<br>    &#125;<br><br>    <span class="hljs-comment">// initCallback的reject参数</span><br>    <span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.pending) &#123;<br>        <span class="hljs-built_in">this</span>.state = states.rejected<br>        <span class="hljs-built_in">this</span>.reason = reason<br>        <span class="hljs-built_in">this</span>.rejectedCbStack.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb.call(<span class="hljs-built_in">this</span>))<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行构造回调函数</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      initCallback(resolve, reject)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      reject(e)<br>    &#125;<br><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resCallback, rejCallback</span>)</span> &#123;<br><br>    <span class="hljs-comment">// 因为then方法参数没有规定类型，这里需要做简单处理</span><br>    resCallback = resCallback <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> ? resCallback : <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v<br>    rejCallback = rejCallback <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> ? rejCallback : <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">throw</span> e<br>    &#125;<br><br>    <span class="hljs-comment">// 根据A+规定 then方法一定返回一个新的Promise 这里我们二话不说先返回一个新的Promise</span><br>    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br><br>      <span class="hljs-comment">// 成功的handleCb逻辑</span><br>      <span class="hljs-keyword">const</span> handleFulfilledCb = <span class="hljs-function">() =&gt;</span> &#123;<br>        asyncFn(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> x = resCallback(<span class="hljs-built_in">this</span>.value)<br>            resolvePromise(p, x, res, rej)<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            rej(e)<br>          &#125;<br>        &#125;)<br>      &#125;<br><br>      <span class="hljs-comment">// 失败的handleCb逻辑</span><br>      <span class="hljs-keyword">const</span> handleRejectedCb = <span class="hljs-function">() =&gt;</span> &#123;<br>        asyncFn(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> x = rejCallback(<span class="hljs-built_in">this</span>.reason)<br>            resolvePromise(p, x, res, rej)<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            rej(e)<br>          &#125;<br>        &#125;)<br>      &#125;<br><br>      <span class="hljs-comment">// 根据当前promise状态执行不同逻辑</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.pending) &#123;<br>        <span class="hljs-comment">// 如果是pending把callback缓存</span><br>        <span class="hljs-built_in">this</span>.fulfilledCbStack.push(handleFulfilledCb)<br>        <span class="hljs-built_in">this</span>.rejectedCbStack.push(handleRejectedCb)<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.fulfilled) &#123;<br>        <span class="hljs-comment">// 如果是fulfilled执行成功的方法</span><br>        <span class="hljs-keyword">return</span> handleFulfilledCb()<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === states.rejected) &#123;<br>        <span class="hljs-comment">// 如果是rejected执行失败的方法</span><br>        <span class="hljs-keyword">return</span> handleRejectedCb()<br>      &#125;<br><br>    &#125;)<br>    <span class="hljs-keyword">return</span> p<br>  &#125;<br>  <span class="hljs-keyword">catch</span> (cb_catch) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, cb_catch)<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> myPromise) <span class="hljs-keyword">return</span> value<br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> &amp;&amp; value.then <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>        value.then(res, rej)<br>      &#125;)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      res(value)<br>    &#125;)<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">_, rej</span>) =&gt;</span> &#123;<br>      rej(value)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">all</span>(<span class="hljs-params">promiseList</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> resCount = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> resList = []<br>      promiseList.forEach(<span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> p = item <span class="hljs-keyword">instanceof</span> myPromise ? item : <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          res(item)<br>        &#125;)<br>        p.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          resList[i] = value<br>          resCount++<br>          <span class="hljs-keyword">if</span> (resCount === promiseList.length) res(resList)<br>        &#125;)<br>        p.catch(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          rej(value)<br>        &#125;)<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">race</span>(<span class="hljs-params">promiseList</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>      promiseList.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> p = item <span class="hljs-keyword">instanceof</span> myPromise ? item : <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          res(item)<br>        &#125;)<br>        p.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          res(value)<br>        &#125;)<br>        p.catch(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          rej(value)<br>        &#125;)<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">allSettled</span>(<span class="hljs-params">promiseList</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> resList = []<br>      promiseList.forEach(<span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> p = item <span class="hljs-keyword">instanceof</span> myPromise ? item : <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          res(item)<br>        &#125;)<br>        p.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          resList[i] = &#123;<br>            <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>,<br>            value<br>          &#125;<br>          <span class="hljs-keyword">if</span> (resList.flat().length === promiseList.length) res(resList)<br>        &#125;)<br>        p.catch(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>          resList[i] = &#123;<br>            <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>,<br>            reason<br>          &#125;<br>          <span class="hljs-keyword">if</span> (resList.flat().length === promiseList.length) res(resList)<br>        &#125;)<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">any</span>(<span class="hljs-params">promiseList</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> resList = <span class="hljs-keyword">new</span> AggregateError()<br>      promiseList.forEach(<span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> p = item <span class="hljs-keyword">instanceof</span> myPromise ? item : <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          res(item)<br>        &#125;)<br>        p.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          res(value)<br>        &#125;)<br>        p.catch(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          resList[i] = value<br>          <span class="hljs-keyword">if</span> (resList.flat().length === promiseList.length) rej(resList)<br>        &#125;)<br>      &#125;)<br>    &#125;)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 测试代码，需要自行先装包</span><br>myPromise.deferred = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> result = &#123;&#125;;<br>  result.promise = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    result.resolve = resolve;<br>    result.reject = reject;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = myPromise;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术探讨</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Promise</tag>
      
      <tag>异步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前同事跟我说js的值类型数据不是存在栈里WTF？值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？--再学JavaScript系列</title>
    <link href="/2021/02/23/%E5%86%8D%E5%AD%A6JavaScript%E7%B3%BB%E5%88%97-%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%B7%9F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%9C%A8%E6%A0%88%E4%B8%8A%E9%9D%A2%E4%B8%8A%E4%B8%80%E5%AE%9A%E6%AD%A3%E7%A1%AE%E5%90%97%EF%BC%9F/"/>
    <url>/2021/02/23/%E5%86%8D%E5%AD%A6JavaScript%E7%B3%BB%E5%88%97-%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%B7%9F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%9C%A8%E6%A0%88%E4%B8%8A%E9%9D%A2%E4%B8%8A%E4%B8%80%E5%AE%9A%E6%AD%A3%E7%A1%AE%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>跟前同事讨论技术，他跟我说JS的值类型不是存在栈里，于是我去学习探讨了一波。本文将分析造成引用类型跟值类型的行为差异的底层原因，V8堆栈模型浅析，以及对一些数据类型的存储机制解析。</p><span id="more"></span><h2 id="值类型和引用类型的特点"><a href="#值类型和引用类型的特点" class="headerlink" title="值类型和引用类型的特点"></a>值类型和引用类型的特点</h2><p>根据JS的定义，或者说ECMAScript的定义总共有八种语言类型：<code>null</code>,<code>undefined</code>,<code>number</code>,<code>boolean</code>,<code>string</code>,<code>symbol</code>,<code>bigint</code>,<code>object</code><br>其中除了 <code>object</code> 其他都是值类型，我们用一段代码来概括其区别:  </p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = a;<br><span class="hljs-attr">a</span> = <span class="hljs-number">2</span> <br>console.log(b); // <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span> = &#123;x: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">d</span> = c;<br>c.<span class="hljs-attr">x</span> = <span class="hljs-number">2</span><br>console.log(c.x); // <span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">e</span> = <span class="hljs-number">2</span> <br><span class="hljs-keyword">let</span> <span class="hljs-attr">f</span> = <span class="hljs-number">2</span><br><span class="hljs-attr">e</span> === f // <span class="hljs-literal">true</span> <br><span class="hljs-keyword">let</span> <span class="hljs-attr">g</span> = &#123;x: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">h</span> = &#123;x: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-attr">g</span> === h // <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="数据在堆栈中的存储"><a href="#数据在堆栈中的存储" class="headerlink" title="数据在堆栈中的存储"></a>数据在堆栈中的存储</h2><p>对于以上现象，先用通俗的解释：<br>对于值类型，其在内存中存储在一个栈当中其中key是变量名，value是具体的值。因此<code>b = a</code>成立因为value完全一致嘛。<br>而对于引用类型，<code>let c = &#123;x: 1&#125;</code> 这行代码先在堆上面开辟一块内存空间,其中存储着 <code>&#123;x:1&#125;</code>这条数据，然后对于变量<code>c</code>其value中存储着这个空间的地址，因此<code>d = c</code>的赋值操作其实是复制了一份地址，而不是数据，二者都指向堆里面的<code>&#123;x: 1&#125;</code>数据，因此当修改二者其中之一时，另一个变量随之改变。对于<code>g</code>跟<code>h</code>两个变量，二者虽然数据一摸一样，但是二者不是同一块内存空间，修改<code>g</code>中的<code>x：1</code>不会改变<code>h</code>中的<code>x</code>因此不相等。<br>图解如下：<br><img src="/2021/02/23/再学JavaScript系列-值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？/srack&heap.jpg" title="堆栈"></p><h2 id="堆栈的空间结构"><a href="#堆栈的空间结构" class="headerlink" title="堆栈的空间结构"></a>堆栈的空间结构</h2><p>栈的空间结构没什么好讲的，就是一块连续的存储空间，再看看堆的存储结构张图:<br><img src="/2021/02/23/再学JavaScript系列-值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？/heap.jpg" title="堆内存结构"><br>其中：  </p><ul><li><p>新生代内存区（new space）<br>新生代内存区会被划分为两个semispace，每个semispace大小默认为16MB也就是说新生代内存区通常只有32MB大小（64位），而这两个semispace分别是from space 和 to space（具体有什么用下文会说），通常新创建的对象会先放入这两个semispace中的一个。</p></li><li><p>老生代内存区（old space）<br>通常会较为持久的保存对象,也分为两个区域 old pointer space 和 old data space分别用来存放GC后还存活的指针信息和数据信息。</p></li><li><p>大对象区（large object space）<br>这里存放体积超越其他区大小的对象，主要为了避免大对象的拷贝，使用该空间专门存储大对象。</p></li><li><p>单元区、属性单元区、Map区（Cell space、property cell space、map space）<br>Map空间存放对象的Map信息也就是隐藏类(Hiden Class）最大限制为8MB；每个Map对象固定大小，为了快速定位，所以将该空间单独出来。</p></li><li><p>代码区 (code Space)<br>主要存放代码对象，最大限制为512MB，也是唯一拥有执行权限的内存</p></li></ul><h2 id="V8引擎中的基本类型存储机制"><a href="#V8引擎中的基本类型存储机制" class="headerlink" title="V8引擎中的基本类型存储机制"></a>V8引擎中的基本类型存储机制</h2><h3 id="一个疑点"><a href="#一个疑点" class="headerlink" title="一个疑点"></a>一个疑点</h3><p>根据上文所说，对于基本类型应该是存储在栈中的，但是V8引擎中一个栈区的大小为984kib 理论上一个字符串的大小不会超过这个数字，但是实际操作中却能声明一个上百mib大小的字符串，如图：  </p><p><img src="/2021/02/23/再学JavaScript系列-值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？/bigString.jpeg" title="堆内存结构"></p><h3 id="V8引擎string的真正存储机制"><a href="#V8引擎string的真正存储机制" class="headerlink" title="V8引擎string的真正存储机制"></a>V8引擎<code>string</code>的真正存储机制</h3><p>因此实际的V8引擎中数据绝不仅仅是简单的栈存储。<br>先说结论，实际上对于 <code>string</code>，先从内存中（哈希表）查找是否有已经创建的完全一致的字符串，如果存在，直接复用。如果不存在，则开辟一块新的内存空间存进这个字符串，然后把地址赋到变量中。同时，这也解释了为啥V8里字符串不能通过下标修改字符串，因为人家本来就是不可变的。<br>我们直接来看一下一段V8的源码验证下： </p><p><img src="/2021/02/23/再学JavaScript系列-值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？/stringTable.png" title="V8 StringTable源码"><br><img src="/2021/02/23/再学JavaScript系列-值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？/getName.jpeg" title="V8 StringTable源码"><br><img src="/2021/02/23/再学JavaScript系列-值类型跟引用类型到底有什么区别？值类型存在栈上面上一定正确吗？/newString.jpeg" title="V8 StringTable源码"></p><p>因此其实我们声明两个相同的字符串时，两个变量的地址（hash）其实是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> BasicVarGen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.s0 = <span class="hljs-string">&#x27;IAmString&#x27;</span><br>    <span class="hljs-built_in">this</span>.s1 = <span class="hljs-string">&#x27;IAmString&#x27;</span><br>&#125;<br><br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> BasicVarGen()<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> BasicVarGen()<br><span class="hljs-comment">//a b中的s0 s1是同一个内存地址（hash）</span><br></code></pre></td></tr></table></figure><h3 id="V8引擎number的存储机制"><a href="#V8引擎number的存储机制" class="headerlink" title="V8引擎number的存储机制"></a>V8引擎<code>number</code>的存储机制</h3><p><code>number</code>在V8中分为 <code>smi</code> 和 <code>heapNumber</code>,<br><code>smi</code> 直接存进内存,范围为 ： -2³¹ 到 2³¹-1（2³¹≈2*10⁹）的整数<br><code>heapNumber</code> 类似字符串,不可变,范围为 ：所有非smi的数字，存进堆里面  </p><p>ECMAScript 标准约定number数字需要被当成 64 位双精度浮点数处理，由于一直使用 64 位去存储任何数字实际是非常低效的（空间低效，计算时间低效 smi大量使用位运算），所以 JavaScript 引擎并不总会使用 64 位去存储数字，引擎在内部可以采用其他内存表示方式（如 32 位），只要保证数字外部所有能被监测到的特性对齐 64 位的表现就行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>值类型跟引用类型在实际使用中需要注意一些使用上的差异，这种差异根据JavaScript引擎会有不同的实现，在V8中并不是所有的值类型都存储在栈内存中，对于V8引擎来说:  </p><ul><li><p><code>string</code>： 存在堆里，栈中为引用地址，如果存在相同字符串，则引用地址相同。</p></li><li><p><code>number</code>： 小整数存在栈中，其他类型存在堆中。</p></li><li><p>其他类型：引擎初始化时分配唯一地址，栈中的变量存的是唯一的引用。</p></li></ul><p>(参考链接：<a href="https://juejin.cn/post/6844904175868837901">https://juejin.cn/post/6844904175868837901</a>)<br>(参考链接：<a href="https://www.zhihu.com/question/482433315/answer/2083349992?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1118537826173702144&amp;utm_content=group1_Answer&amp;utm_campaign=shareopn">https://www.zhihu.com/question/482433315/answer/2083349992?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1118537826173702144&amp;utm_content=group1_Answer&amp;utm_campaign=shareopn</a>)</p>]]></content>
    
    
    <categories>
      
      <category>技术探讨</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>V8</tag>
      
      <tag>堆栈模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记--《JavaScript教程》《JavaScript高级程序设计》关键知识点笔记</title>
    <link href="/2020/09/23/JavaScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/09/23/JavaScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>此篇是博主在阅读这两本JavaScript入门书籍时记得一些笔记，以及一些知识点，长期更新，文中有错误欢迎指正，有不同理解欢迎交流。</p><span id="more"></span><h2 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一.数据类型"></a>一.数据类型</h2><p>在es5之前总共有：<em>null</em> <em>undefined</em> <em>boolean</em> <em>object</em> <em>string</em> <em>number</em> 六种数据类型，es6新增了 <em>symbol</em> ,es11新增了 <em>bigint</em> </p><p>所以截止es2021，目前总共有：<em>null</em> <em>undefined</em> <em>boolean</em> <em>object</em> <em>string</em> <em>number</em> <em>symbol</em> <em>bigint</em> 基本数据类型</p><p>ps：这些也是 <code>typeof</code> 能返回的所有值</p><h3 id="原始类型和引用类型"><a href="#原始类型和引用类型" class="headerlink" title="原始类型和引用类型"></a>原始类型和引用类型</h3><p>一版来说JavaScript的数据类型分为两大类，原始类型和引用类型，其中<em>null</em> <em>undefined</em> <em>boolean</em> <em>number</em> <em>symbol</em> <em>bigint</em> <em>string</em> 都是基本数据类型。<br>基本数据类型中除了<code>null</code> 跟 <code>undefined</code> 都有包装对象，在你调用这些基本类型的属性跟方法的时候其实就是创建了一个临时的包装对象，然后执行对应的属性跟方法，执行完之后就销毁。<br>值得一提的是虽然 <code>symbol</code> 跟 <code>bigint</code> 有包装对象但是没有构造函数，所以使用 <code>new</code> 操作会报错。</p><h3 id="数据类型判断的三个原生方法"><a href="#数据类型判断的三个原生方法" class="headerlink" title="数据类型判断的三个原生方法"></a>数据类型判断的三个原生方法</h3><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.<code>typeof</code></h4><p>数值、字符串、布尔值分别返回number、string、boolean，函数返回function，undefined返回undefined，对象返回object，null返回object。</p><p>ps：<code>typeof null // object</code> 其实是历史原因,1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。</p><h4 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.<code>instanceof</code></h4><p><code>instanceof</code> 运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p><p><code>instanceof</code> 是基于原型链查找，运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const v = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vehicle()</span><br>v instanceof Vehicle<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vehicle</span>.</span></span>prototype.is<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">v</span>)</span><br></code></pre></td></tr></table></figure><h4 id="3-Object-prototype-toString"><a href="#3-Object-prototype-toString" class="headerlink" title="3.Object.prototype.toString"></a>3.<code>Object.prototype.toString</code></h4><p>因为大部分数据类型都自定义重写了toString方法，一次可以根据此方法的返回值去判断数据类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript">数值：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Number</span>]。<br>字符串：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">String</span>]。<br>布尔值：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Boolean</span>]。<br><span class="hljs-literal">undefined</span>：返回[<span class="hljs-built_in">object</span> Undefined]。<br><span class="hljs-literal">null</span>：返回[<span class="hljs-built_in">object</span> Null]。<br>数组：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Array</span>]。<br><span class="hljs-built_in">arguments</span> 对象：返回[<span class="hljs-built_in">object</span> Arguments]。<br>函数：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Function</span>]。<br><span class="hljs-built_in">Error</span> 对象：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Error</span>]。<br><span class="hljs-built_in">Date</span> 对象：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Date</span>]。<br><span class="hljs-built_in">RegExp</span> 对象：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">RegExp</span>]。<br>其他对象：返回[<span class="hljs-built_in">object</span> <span class="hljs-built_in">Object</span>]。<br>symbol对象：返回<span class="hljs-built_in">Symbol</span>()<br></code></pre></td></tr></table></figure><h2 id="二-运算符"><a href="#二-运算符" class="headerlink" title="二.运算符"></a>二.运算符</h2><p>加法运算符：<code>x + y</code><br>减法运算符： <code>x - y</code><br>乘法运算符： <code>x * y</code><br>除法运算符：<code>x / y</code><br>指数运算符：<code>x ** y</code><br>余数运算符：<code>x % y</code><br>自增运算符：<code>++x 或者 x++</code><br>自减运算符：<code>--x 或者 x--</code><br>数值运算符： <code>+x</code><br>负数值运算符：<code>-x</code>  </p><h3 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符 +"></a>加法运算符 <code>+</code></h3><p>上面这些运算符号值得说的其实就是 <code>+</code> 运算符，加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。<br>比如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>+ true // <span class="hljs-number">2</span><br><span class="hljs-comment">&#x27;3&#x27; + 4 + 5 // &quot;345&quot;</span><br><span class="hljs-symbol">3 </span>+ <span class="hljs-number">4</span> + <span class="hljs-comment">&#x27;5&#x27; // &quot;75&quot;</span><br></code></pre></td></tr></table></figure><h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符 **"></a>指数运算符 <code>**</code></h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>** <span class="hljs-number">4</span> // <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>指数运算符需要注意的是，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 相当于 <span class="hljs-number">2</span> ** (<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>)<br> <span class="hljs-number">2</span> ** <span class="hljs-number">3</span> ** <span class="hljs-number">2</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">512</span><br></code></pre></td></tr></table></figure><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><p>布尔运算符就以下四种：  </p><ul><li>取反运算符：<code>!</code></li><li>且运算符：<code>&amp;&amp;</code></li><li>或运算符：<code>||</code></li><li>三元运算符：<code>?:</code></li></ul><h4 id="1-取反运算符："><a href="#1-取反运算符：" class="headerlink" title="1.取反运算符：!"></a>1.取反运算符：<code>!</code></h4><p><code>!</code>运算符会把布尔值变成相反值，值得注意的是也能对非布尔值取反，只要记住以下取反是<code>true</code>其他都是<code>false</code>:  </p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>false</code></li><li><code>0</code></li><li><code>NaN</code></li><li><code>&#39;&#39;</code></li></ul><p>小tips：对一个变量两次取反就是把变量变成对应的<code>boolean</code>值，相当于<code>Boolean()</code>方法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">!!x<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-title">Boolean</span><span class="hljs-params">(x)</span></span><br></code></pre></td></tr></table></figure><h4 id="2-且运算符：-amp-amp"><a href="#2-且运算符：-amp-amp" class="headerlink" title="2.且运算符：&amp;&amp;"></a>2.且运算符：<code>&amp;&amp;</code></h4><p>它的运算规则是：如果第一个运算子的布尔值为 <code>true</code>，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为 <code>false</code>，则直接返回第一个运算子的值，且不再对第二个运算子求值。<br>ps：经常拿来代替 <code>if</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (i) &#123;<br>  <span class="hljs-selector-tag">doSomething</span>();<br>&#125;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-tag">&amp;</span> <span class="hljs-selector-tag">doSomething</span>();<br></code></pre></td></tr></table></figure><h4 id="3-或运算符："><a href="#3-或运算符：" class="headerlink" title="3.或运算符：||"></a>3.或运算符：<code>||</code></h4><p>它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。<br>ps：经常拿来设置一个变量的默认值</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>() || <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="4-三元运算符："><a href="#4-三元运算符：" class="headerlink" title="4.三元运算符：?:"></a>4.三元运算符：<code>?:</code></h4><p>三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。<br>ps: 经常拿来代替if else 非常的简便好用,而且具有返回值</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> isBoy = sex===<span class="hljs-string">&#x27;男&#x27;</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>二进制位运算符用于直接对二进制位进行计算，一共有7个。</p><ul><li>二进制或运算符（or）：符号为<code>|</code>，表示若两个二进制位都为0，则结果为0，否则为1。</li><li>二进制与运算符（and）：符号为<code>&amp;</code>，表示若两个二进制位都为1，则结果为1，否则为0。</li><li>二进制否运算符（not）：符号为<code>~</code>，表示对一个二进制位取反。</li><li>异或运算符（xor）：符号为<code>^</code>，表示若两个二进制位不相同，则结果为1，否则为0。</li><li>左移运算符（left shift）：符号为<code>&lt;&lt;</code>。</li><li>右移运算符（right shift）：符号为<code>&gt;&gt;</code>。</li><li>头部补零的右移运算符（zero filled right shift）：符号为<code>&gt;&gt;&gt;</code>。</li></ul><p>有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。</p><p>前四个根据上面的字面意思自己理解，这里写一些比较有意思的位运算操作:  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 把i转成成一个整数<br>i = i | <span class="hljs-number">0</span> <br><br><span class="hljs-regexp">//</span> 不依赖第三个变量交换ab的值<br>var a = <span class="hljs-number">10</span>;<br>var b = <span class="hljs-number">99</span>;<br>a ^= b, b ^= a, a ^= b;<br>a <span class="hljs-regexp">//</span> <span class="hljs-number">99</span><br>b <span class="hljs-regexp">//</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h4 id="左移运算符-lt-lt"><a href="#左移运算符-lt-lt" class="headerlink" title="左移运算符 &lt;&lt;"></a>左移运算符 <code>&lt;&lt;</code></h4><p>左移运算符（&lt;&lt;）表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方。向左移动的时候，最高位的符号位是一起移动的。</p><h4 id="右移运算符-gt-gt"><a href="#右移运算符-gt-gt" class="headerlink" title="右移运算符 &gt;&gt;"></a>右移运算符 <code>&gt;&gt;</code></h4><p>右移运算符（&gt;&gt;）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补0；如果是负数，头部全部补1。右移运算符基本上相当于除以2的指定次方（最高位即符号位参与移动）。</p><h4 id="左移运算符-gt-gt-gt"><a href="#左移运算符-gt-gt-gt" class="headerlink" title="左移运算符 &gt;&gt;&gt;"></a>左移运算符 <code>&gt;&gt;&gt;</code></h4><p>头部补零的右移运算符（&gt;&gt;&gt;）与右移运算符（&gt;&gt;）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（&gt;&gt;）完全一致，区别主要在于负数。<br>查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">-<span class="hljs-number">1</span> &gt;&gt;&gt; <span class="hljs-number">0</span> <span class="hljs-regexp">//</span> <span class="hljs-number">4294967295</span><br></code></pre></td></tr></table></figure><h2 id="JavaScript类型转换"><a href="#JavaScript类型转换" class="headerlink" title="JavaScript类型转换"></a>JavaScript类型转换</h2><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>1.<code>Number()</code>  </p><p>对于基本类型直接转换，对于对象：  </p><p>第一步，调用对象自身的<code>valueOf</code>方法。如果返回原始类型的值，则直接对该值使用<code>Number</code>函数，不再进行后续步骤。  </p><p>第二步，如果<code>valueOf</code>方法返回的还是对象，则改为调用对象自身的<code>toString</code>方法。如果<code>toString</code>方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。</p><p>第三步，如果<code>toString</code>方法返回的是对象，就报错。  </p><p><code>Number()</code> 比 <code>parseInt</code>严哥很多，只要有一个字没法转换成数值就会转成NaN  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">parseInt</span><span class="hljs-params">(<span class="hljs-string">&#x27;42 cats&#x27;</span>)</span></span> <span class="hljs-comment">// 42</span><br><span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(<span class="hljs-string">&#x27;42 cats&#x27;</span>)</span></span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>2.<code>String()</code>  </p><p>与``Number<code>基本相同，只是先执行</code>toString<code>，结果不符合再执行 </code>valueOf`  </p><p>3.<code>Boolean()</code>  </p><p>除了以下五个转换为<code>false</code>，其他所以值都是<code>true</code> 甚至包括 <code>false</code> 的包装对象  </p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>0（包含-0和+0）</code></li><li><code>NaN</code></li><li><code>&#39;&#39;（空字符串）</code></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Boolean</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="自动转换（隐式转换）"><a href="#自动转换（隐式转换）" class="headerlink" title="自动转换（隐式转换）"></a>自动转换（隐式转换）</h3><p>出现情况主要有以下这些情况：  </p><ul><li>不同类型的数据互相运算 <code>123 + &#39;abc&#39; // &quot;123abc&quot;</code></li><li>对非布尔值类型的数据求布尔值 <code>if(&#39;abc&#39;)</code></li><li>对非数值类型的值使用一元运算符 <code>+ &#123;foo: &#39;bar&#39;&#125; // NaN</code></li></ul><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h3><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>1.<code>Object.keys()</code> 与 <code>Object.getOwnPropertyNames()</code>  </p><p>这两个方法都是返回对像自身的属性名集合，结果是一个数组。区别是：<br>前者不会返回不可枚举的属性名，后者会。</p><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>1.<code>Object.prototype.valueOf()</code> 返回当前对象的对应值  </p><p>默认返回对象本身，在一些类型转换的情况，比如 <code>1 + obj &quot;1[object Object]&quot;</code> 时会调用这个方法，可以重写以实现一些特殊的现象。  </p><p>2.<code>Object.prototype.toString() </code> 返回当前对象对应的字符串形式  </p><p>默认返回<code>&quot;[object Object]&quot;</code>,在跟字符串做加法时会调用这个方法，并且可使用这个方法判断数据类型</p><p>3.<code>Object.prototype.toLocaleString()</code> 返回当前对象对应的本地字符串形式  </p><p><code>Object.prototype.toLocaleString</code>方法与<code>toString</code>的返回结果相同，也是返回一个值的字符串形式。<br>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的<code>toLocaleString</code>，用来返回针对某些地域的特定的值。</p><p>4.<code>Object.prototype.hasOwnProperty()</code> 判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。  </p><p>ps： 可以遍历属性的不可枚举属性</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
