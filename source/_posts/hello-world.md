---
title: 读书笔记--《JavaScript教程》《JavaScript高级程序设计》关键知识点笔记
date: 2020-09-23 19:20:33
categories: ['读书笔记']
tag: ['笔记','学习','JavaScript']
comments: true
---

此篇是博主在阅读这两本JavaScript入门书籍时记得一些笔记，以及一些知识点，长期更新，文中有错误欢迎指正，有不同理解欢迎交流。

<!-- more -->

## 一.数据类型

在es5之前总共有：*null* *undefined* *boolean* *object* *function* *number* 六种数据类型，es6新增了 *symbol* ,es11新增了 *bigint* 

所以截止es2021，目前总共有：*null* *undefined* *boolean* *object* *function* *number* *symbol* *bigint* 基本数据类型

ps：这些也是 `typeof` 能返回的所有值

### 数据类型判断的三个原生方法

#### 1.`typeof`
数值、字符串、布尔值分别返回number、string、boolean，函数返回function，undefined返回undefined，对象返回object，null返回object。

ps：`typeof null // object` 其实是历史原因,1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。

#### 2.`instanceof` 
`instanceof` 运算符返回一个布尔值，表示对象是否为某个构造函数的实例。

`instanceof` 是基于原型链查找，运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。
```
const v = new Vehicle()
v instanceof Vehicle
// 等同于
Vehicle.prototype.isPrototypeOf(v)
```
#### 3.`Object.prototype.toString`
因为大部分数据类型都自定义重写了toString方法，一次可以根据此方法的返回值去判断数据类型
```
数值：返回[object Number]。
字符串：返回[object String]。
布尔值：返回[object Boolean]。
undefined：返回[object Undefined]。
null：返回[object Null]。
数组：返回[object Array]。
arguments 对象：返回[object Arguments]。
函数：返回[object Function]。
Error 对象：返回[object Error]。
Date 对象：返回[object Date]。
RegExp 对象：返回[object RegExp]。
其他对象：返回[object Object]。
symbol对象：返回Symbol()
```

## 二.运算符
加法运算符：`x + y`   
减法运算符： `x - y`  
乘法运算符： `x * y`  
除法运算符：`x / y`  
指数运算符：`x ** y`  
余数运算符：`x % y`  
自增运算符：`++x 或者 x++`  
自减运算符：`--x 或者 x--`  
数值运算符： `+x`  
负数值运算符：`-x`  

### 加法运算符 `+`
上面这些运算符号值得说的其实就是 `+` 运算符，加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。
比如：
```
 1 + true // 2
 '3' + 4 + 5 // "345"
 3 + 4 + '5' // "75"
```
### 指数运算符 `**` 
```
 2 ** 4 // 16
```
指数运算符需要注意的是，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。
```
// 相当于 2 ** (3 ** 2)
 2 ** 3 ** 2
// 512
```
### 布尔运算符
布尔运算符就以下四种：  
* 取反运算符：`!`
* 且运算符：`&&`
* 或运算符：`||`
* 三元运算符：`?:`

#### 1.取反运算符：`!`
`!`运算符会把布尔值变成相反值，值得注意的是也能对非布尔值取反，只要记住以下取反是`true`其他都是`false`:  
* `undefined`
* `null`
* `false`
* `0`
* `NaN`
* `''`
  
小tips：对一个变量两次取反就是把变量变成对应的`boolean`值，相当于`Boolean()`方法
```
!!x
// 等同于
Boolean(x)
```

#### 2.且运算符：`&&`
它的运算规则是：如果第一个运算子的布尔值为 `true`，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为 `false`，则直接返回第一个运算子的值，且不再对第二个运算子求值。  
ps：经常拿来代替 `if`
```
if (i) {
  doSomething();
}
// 等价于
i && doSomething();
```
#### 3.或运算符：`||`
它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。  
ps：经常拿来设置一个变量的默认值
```
const str = new String() || ''
```

#### 4.三元运算符：`?:`
三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。  
ps: 经常拿来代替if else 非常的简便好用,而且具有返回值
```
const isBoy = sex==='男' ? true : false
```
### 位运算符
二进制位运算符用于直接对二进制位进行计算，一共有7个。

* 二进制或运算符（or）：符号为`|`，表示若两个二进制位都为0，则结果为0，否则为1。
* 二进制与运算符（and）：符号为`&`，表示若两个二进制位都为1，则结果为1，否则为0。
* 二进制否运算符（not）：符号为`~`，表示对一个二进制位取反。
* 异或运算符（xor）：符号为`^`，表示若两个二进制位不相同，则结果为1，否则为0。
* 左移运算符（left shift）：符号为`<<`。
* 右移运算符（right shift）：符号为`>>`。
* 头部补零的右移运算符（zero filled right shift）：符号为`>>>`。

有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。

前四个根据上面的字面意思自己理解，这里写一些比较有意思的位运算操作:  
```
// 把i转成成一个整数
i = i | 0 

// 不依赖第三个变量交换ab的值
var a = 10;
var b = 99;
a ^= b, b ^= a, a ^= b;
a // 99
b // 10
```
#### 左移运算符 `<<`
左移运算符（<<）表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方。向左移动的时候，最高位的符号位是一起移动的。
#### 右移运算符 `>>`
右移运算符（>>）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补0；如果是负数，头部全部补1。右移运算符基本上相当于除以2的指定次方（最高位即符号位参与移动）。
#### 左移运算符 `>>>`
头部补零的右移运算符（>>>）与右移运算符（>>）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（>>）完全一致，区别主要在于负数。  
查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。
```
-1 >>> 0 // 4294967295
```

